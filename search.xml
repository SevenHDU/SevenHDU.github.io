<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Hexo]]></title>
      <url>http://www.sevenhdu.space/2016/09/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决在IOS下无法自动播放音频的问题]]></title>
      <url>http://www.sevenhdu.space/2016/09/21/autoplay-auido-in-ios/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道在IOS下H5页面是无法自动播放音频，必须通过用户交互比如点击等才能播放音频。IOS是为了防止偷跑流量才这么做的。但是很多H5项目中播放背景音频是一个很习以为常的需求。那该怎么办呢？答案就在微信的WeixinJSBridgeReady事件。</p>
<a id="more"></a>
<blockquote>
<p>JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action.</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>WeixinJSBridgeReady是微信自带的事件，只要监听这个事件，在执行函数里播放音频，就可以实现在微信中自动播放音频的功能。（毕竟微信渠道的量大，一定要保证微信是可以正常播放音频）</p>
<pre><code class="html">&lt;audio src=&quot;bgAudio.mp3&quot; id=&quot;bgAudio&quot; preload loop=&quot;loop&quot;&gt;&lt;/audio&gt;
</code></pre>
<pre><code class="javascript">function playBgAudio(){
    var bgAudio = document.getElementById(&quot;bgAudio&quot;);
    bgAudio.play();

    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function(){
        bgAudio.play();
    }, false);
}
</code></pre>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>很多同学发现用了上面的代码也没什么卵用，因为这里面还有个坑。上面的代码必须放在WeixinJSBridgeReady执行以前，如果WeixinJSBridgeReady事件都执行，再监听就没什么用了。<strong><em>所以监听的js代码一定要放在head前面，以确保最先执行</em></strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS中的伪类和伪元素]]></title>
      <url>http://www.sevenhdu.space/2015/03/05/css-pseudo-class-and-pseudo-elments/</url>
      <content type="html"><![CDATA[<p>先看<code>W3C</code>的定义<br>. <strong>CSS伪类</strong> 用于向某些选择器添加特殊的效果<br>. <strong>CSS伪元素</strong> 用于向某些选择器设置特殊效果</p>
<p>光看定义，其实还是云里雾里的，所以还是要深入研究下才能搞明白他们的作用。</p>
<a id="more"></a>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪类与类相似，但又没有类附加标签上。伪类分为UI伪类和结构化伪类。</p>
<h3 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h3><ul>
<li>:link(将样式添加到未被访问的链接上)</li>
<li>:visted(将样式已添加到访问的链接上)</li>
<li>:hover(将样式添加到鼠标悬浮的元素上)</li>
<li>:active(将样式添加到被激活的元素上)</li>
<li>:focus(将样式添加到被选中的元素上)</li>
</ul>
<h3 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h3><ul>
<li>:first-child(将样式添加到第一个子元素上)</li>
<li>:last-child(将样式添加到最后一个子元素上)</li>
</ul>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素是在文档中若有实无的元素。<br>主要有以下几种</p>
<ul>
<li>:first-letter(将样式添加到第一个字母)</li>
<li>:first-line(将样式添加到第一行)</li>
<li>:before(在某些元素前面插入某些内容)</li>
<li>:after(在某些元素后面插入某些内容)</li>
</ul>
<p>看到:after，大家脑子里应该都能想到那个经典的清除浮动的CSS的吧。没错，就是这个。</p>
<pre><code class="css">.clearfix:after {
    content:&quot;.&quot;;
    display:block;
    height:0;
    visibility:hidden;
    clear:both;
}
</code></pre>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p><strong>伪类的实现就好比给这个标签添加了一个虚拟的类。</strong><br>举个栗子</p>
<pre><code class="html">a:hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>若不用伪类，实现同样的效果，需要这么做</p>
<pre><code class="html">.hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>这么一对比，”伪类“的概念是不是清晰了很多。</p>
<p><strong>而伪元素则好比添加了一个新的标签。</strong></p>
<pre><code class="html">p:first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;Hello,World&lt;/p&gt;
</code></pre>
<p>若不用伪元素，实现同样的效果，需要添加一个额外的标签</p>
<pre><code class="html">.first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;&lt;span class=&quot;first-letter&quot;&gt;H&lt;/span&gt;ello,World&lt;/p&gt;
</code></pre>
<p>因此总结下区分的方法：<strong>现实相同效果是需要添加一个类还是一个元素标签。</strong></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>CSS3为了区别伪类和伪元素，明确使用单冒号来表示伪类，双冒号来表示伪元素。但为兼容性考虑，目前基本还是使用单冒号来表示。</li>
<li>搜索引擎不会搜索伪元素的信息。因此，不要通过伪元素添加你想让搜索引擎索引的重要内容</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解DOM事件流]]></title>
      <url>http://www.sevenhdu.space/2014/10/16/dom-event-flow/</url>
      <content type="html"><![CDATA[<p>当浏览器发展到第四代时（IE4和Netscape Communicator 4）,浏览器团队遇到一个很有意思的问题：页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面。<br>事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流。</p>
<a id="more"></a>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。看下面的例子</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>点击按钮，那么这个click事件会按照以下顺序传播：<br>1.input<br>2.div<br>3.body<br>4.html<br>5.document</p>
<p>虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获。</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。以前面的例子，则会按下图顺序触发事件。</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-15/54841141-file_1487127495480_10fd7.png" alt="事件流"></p>
<p>在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到div后就停止了。下一个阶段是处于目标阶段，于是事件在input上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。</p>
<p>多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上操作事件。  看如下例子。</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;wrap&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var wrap = document.getElementById(&quot;wrap&quot;);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;冒泡&quot;);
            }, false);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;捕获&quot;);
            }, true)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这个Demo的结果，应该很清楚了吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DB2日期分组计算数据值]]></title>
      <url>http://www.sevenhdu.space/2014/08/18/DB2-sum-groupby/</url>
      <content type="html"><![CDATA[<p>最近参与的项目进行了一次优化技改，对其中SQL参数化公用方法进行了改造。又因项目组人员调整，接手其他模块。</p>
<p>在其他模块测试过程发现，一个针对日期分组计算的SQL报错，报SQL语句超长的异常。</p>
<a id="more"></a>
<p>举个栗子，功能要求如下：</p>
<p>表TABLE_TEST中</p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:center">AMOUNT</th>
<th style="text-align:right">CREATE_DATE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-01</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-09</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-11</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-21</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-24</td>
</tr>
</tbody>
</table>
<p>需求是从表中按CREAT_DATE每10天作为一个分组，统计总金额</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>之前的SQL是这样子的</p>
<pre><code class="SQL">SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-01&#39; AND &#39;2014-01-10&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-11&#39; AND &#39;2014-01-20&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-21&#39; AND &#39;2014-01-30&#39;
</code></pre>
<p>这个SQL主要有两方面问题，一方面程序逻辑发杂，需要算计每10天时间间隔的起始日期，还有一个方面是SQL语句冗长，如果日期跨度大的话，SQL语句就回相当长，直接导致程序抛异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>改进的SQL</p>
<pre><code class="SQL">SELECT SUM(AMOUNT) AS TOTALAMOUNT , (days(CREATE_DATE)-days(&#39;2014-01-01&#39;))/10 AS TIMESAPN
FROM TABLE_TEST GROUP BY TIMESAPN
</code></pre>
<p>关键部分在于  <strong>(days(CREATE_DATE)-days(‘2014-01-01’))/10 AS TIMESAPN</strong></p>
<p>TIMESAPN为0则表示该记录在第一个10天周期内，为1表示在第二个10天周期内，以此类推，最后以此字段作为分组条件，就可以达到上面SQL同样的效果。</p>
]]></content>
    </entry>
    
  
  
</search>
