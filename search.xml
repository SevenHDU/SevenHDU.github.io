<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[如何在移动端触发手机拨打电话]]></title>
      <url>http://www.sevenhdu.space/2017/03/15/make-call-in-mobile/</url>
      <content type="html"><![CDATA[<p>在移动端的项目中，经常会有这样的需求，点击按钮触发手机拨打电话。<br><a id="more"></a><br>这个需求其实很简单，按照下面的写法其实就可以实现。</p>
<pre><code class="html">&lt;a href=&quot;tel:10086&quot;&gt;拨打电话&lt;/a&gt;
</code></pre>
<p>而最近遇到的需求是电话号码动态变化的，因此想着能不能通过js来动态触发这个动作。搜了一下果然是有方法的。</p>
<pre><code class="javascript">function makeCall(telNo){
    window.location.href = &quot;tel:&quot; + telNo;
}
</code></pre>
<p>亲测，在IOS中微信、Safari、UC以及Android中的微信、UC均可触发拨打电话效果。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决在IOS下无法自动播放音频的问题]]></title>
      <url>http://www.sevenhdu.space/2016/09/21/autoplay-auido-in-ios/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道在IOS下H5页面是无法自动播放音频，必须通过用户交互比如点击等才能播放音频。IOS是为了防止偷跑流量才这么做的。但是很多H5项目中播放背景音频是一个很习以为常的需求。那该怎么办呢？答案就在微信的WeixinJSBridgeReady事件。</p>
<a id="more"></a>
<blockquote>
<p>JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action.</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>WeixinJSBridgeReady是微信自带的事件，只要监听这个事件，在执行函数里播放音频，就可以实现在微信中自动播放音频的功能。（毕竟微信渠道的量大，一定要保证微信是可以正常播放音频）</p>
<pre><code class="html">&lt;audio src=&quot;bgAudio.mp3&quot; id=&quot;bgAudio&quot; preload loop=&quot;loop&quot;&gt;&lt;/audio&gt;
</code></pre>
<pre><code class="javascript">function playBgAudio(){
    var bgAudio = document.getElementById(&quot;bgAudio&quot;);
    bgAudio.play();

    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function(){
        bgAudio.play();
    }, false);
}
</code></pre>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>很多同学发现用了上面的代码也没什么卵用，因为这里面还有个坑。上面的代码必须放在WeixinJSBridgeReady执行以前，如果WeixinJSBridgeReady事件都执行，再监听就没什么用了。<strong><em>所以监听的js代码一定要放在head前面，以确保最先执行</em></strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[fixed定位元素在设置了transform属性父元素下失效]]></title>
      <url>http://www.sevenhdu.space/2016/09/17/position-fixed-not-work-in-transform/</url>
      <content type="html"><![CDATA[<p>最近项目开发中遇到了一个奇怪的现象，<code>position:fixed</code>设置元素竟然不相对浏览器定位。最后发现原来是transform捣的鬼。<br>当fixed元素作为transform元素的资源时，<code>position:fixed</code>固定效果将失效，降级成类似<code>position:absolute</code>的表现。</p>
<a id="more"></a>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><iframe height="265" scrolling="no" title="jBaKqW" src="//codepen.io/SevenHDU/embed/jBaKqW/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/SevenHDU/pen/jBaKqW/" target="_blank" rel="external">jBaKqW</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>看完上面的例子，应该就清晰很多了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/" target="_blank" rel="external">CSS3 transform对普通元素的N多渲染影响</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Atom编辑器快捷键大全]]></title>
      <url>http://www.sevenhdu.space/2016/03/24/Atom-shortcut-keys/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：futantan<br>原文地址：<a href="https://github.com/futantan/atom" target="_blank" rel="external">https://github.com/futantan/atom</a></p>
</blockquote>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-24/13908820-file_1487866405842_16c03.png" alt=""></p>
<a id="more"></a>
<h2 id="文件切换"><a href="#文件切换" class="headerlink" title="文件切换"></a>文件切换</h2><p><code>ctrl-shift-s</code>  保存所有打开的文件<br><code>cmd-shift-o</code>  打开目录<br><code>cmd-\</code>   显示或隐藏目录树<br><code>ctrl-0</code>   焦点移到目录树<br>目录树下，使用a，m，delete来增加，修改和删除<br><code>cmd-t</code>或<code>cmd-p</code> 查找文件<br><code>cmd-b</code> 在打开的文件之间切换<br><code>cmd-shift-b</code> 只搜索从上次git commit后修改或者新增的文件</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>（等价于上下左右）<br><code>ctrl-p</code> 前一行<br><code>ctrl-n</code> 后一行<br><code>ctrl-f</code> 前一个字符<br><code>ctrl-b</code> 后一个字符  </p>
<p><code>alt-B</code>, <code>alt-left</code> 移动到单词开始<br><code>alt-F</code>, <code>alt-right</code> 移动到单词末尾  </p>
<p><code>cmd-right</code>, <code>ctrl-E</code> 移动到一行结束<br><code>cmd-left</code>, <code>ctrl-A</code>  移动到一行开始  </p>
<p><code>cmd-up</code> 移动到文件开始<br><code>cmd-down</code> 移动到文件结束  </p>
<p><code>ctrl-g</code> 移动到指定行 row:column 处</p>
<p><code>cmd-r</code> 在方法之间跳转</p>
<h2 id="目录树操作"><a href="#目录树操作" class="headerlink" title="目录树操作"></a>目录树操作</h2><p><code>cmd-\</code> 或者 <code>cmd-k cmd-b</code> 显示(隐藏)目录树<br><code>ctrl-0</code> 焦点切换到目录树(再按一次或者<code>Esc</code>退出目录树)<br><code>a</code> 添加文件<br><code>d</code> 将当前文件另存为(duplicate)<br><code>i</code> 显示(隐藏)版本控制忽略的文件<br><code>alt-right</code> 和 <code>alt-left</code> 展开(隐藏)所有目录<br><code>ctrl-al-]</code> 和 <code>ctrl-al-[</code> 同上<br><code>ctrl-[</code> 和 <code>ctrl-]</code> 展开(隐藏)当前目录<br><code>ctrl-f</code> 和 <code>ctrl-b</code> 同上<br><code>cmd-k h</code> 或者 <code>cmd-k left</code> 在左半视图中打开文件<br><code>cmd-k j</code> 或者 <code>cmd-k down</code> 在下半视图中打开文件<br><code>cmd-k k</code> 或者 <code>cmd-k up</code> 在上半视图中打开文件<br><code>cmd-k l</code> 或者 <code>cmd-k right</code> 在右半视图中打开文件<br><code>ctrl-shift-C</code> 复制当前文件绝对路径</p>
<h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p><code>cmd-F2</code> 在本行增加书签<br><code>F2</code> 跳到当前文件的下一条书签<br><code>shift-F2</code> 跳到当前文件的上一条书签<br><code>ctrl-F2</code> 列出当前工程所有书签  </p>
<h2 id="选取"><a href="#选取" class="headerlink" title="选取"></a>选取</h2><blockquote>
<p>大部分和导航一致，只不过加上shift  </p>
</blockquote>
<p><code>ctrl-shift-P</code>  选取至上一行<br><code>ctrl-shift-N</code>  选取至下一样<br><code>ctrl-shift-B</code>  选取至前一个字符<br><code>ctrl-shift-F</code>  选取至后一个字符<br><code>alt-shift-B</code>, <code>alt-shift-left</code>  选取至字符开始<br><code>alt-shift-F</code>, <code>alt-shift-right</code>  选取至字符结束<br><code>ctrl-shift-E</code>, <code>cmd-shift-right</code>  选取至本行结束<br><code>ctrl-shift-A</code>, <code>cmd-shift-left</code>  选取至本行开始<br><code>cmd-shift-up</code>  选取至文件开始<br><code>cmd-shift-down</code>  选取至文件结尾<br><code>cmd-A</code>  全选<br><code>cmd-L</code>  选取一行，继续按回选取下一行<br><code>ctrl-shift-W</code>  选取当前单词  </p>
<h2 id="编辑和删除文本"><a href="#编辑和删除文本" class="headerlink" title="编辑和删除文本"></a>编辑和删除文本</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>ctrl-T</code> 使光标前后字符交换<br><code>cmd-J</code> 将下一行与当前行合并<br><code>ctrl-cmd-up</code>, <code>ctrl-cmd-down</code> 使当前行向上或者向下移动<br><code>cmd-shift-D</code> 复制当前行到下一行<br><code>cmd-K</code>, <code>cmd-U</code> 使当前字符大写<br><code>cmd-K</code>, <code>cmd-L</code> 使当前字符小写<br><code>cmd-shift-P</code> 搜索命令  </p>
<h3 id="删除和剪切"><a href="#删除和剪切" class="headerlink" title="删除和剪切"></a>删除和剪切</h3><p><code>ctrl-shift-K</code> 删除当前行<br><code>cmd-backspace</code> 删除到当前行开始<br><code>cmd-fn-backspace</code> 删除到当前行结束<br><code>ctrl-K</code> 剪切到当前行结束<br><code>alt-backspace</code> 或 <code>alt-H</code> 删除到当前单词开始<br><code>alt-delete</code> 或 <code>alt-D</code> 删除到当前单词结束  </p>
<h3 id="多光标和多处选取"><a href="#多光标和多处选取" class="headerlink" title="多光标和多处选取"></a>多光标和多处选取</h3><p><code>cmd-click</code> 增加新光标<br><code>cmd-shift-L</code> 将多行选取改为多行光标<br><code>ctrl-shift-up</code>, <code>ctrl-shift-down</code> 增加上（下）一行光标<br><code>cmd-D</code> 选取文档中和当前单词相同的下一处<br><code>ctrl-cmd-G</code> 选取文档中所有和当前光标单词相同的位置  </p>
<h3 id="括号跳转"><a href="#括号跳转" class="headerlink" title="括号跳转"></a>括号跳转</h3><p><code>ctrl-m</code> 相应括号之间，html tag之间等跳转<br><code>ctrl-cmd-m</code> 括号(tag)之间文本选取<br><code>alt-cmd-.</code> 关闭当前XML/HTML tag  </p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p><code>ctrl-shift-U</code> 调出切换编码选项  </p>
<h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><p><code>cmd-F</code> 在buffer中查找<br><code>cmd-shift-f</code> 在整个工程中查找  </p>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p><code>alt-shift-S</code> 查看当前可用代码片段  </p>
<blockquote>
<p>在<code>~/.atom</code>目录下<code>snippets.cson</code>文件中存放了你定制的snippets  </p>
</blockquote>
<p><a href="https://atom.io/docs/v1.0.0/using-atom-snippets" target="_blank" rel="external">定制说明</a>  </p>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p><code>ctrl-space</code> 提示补全信息  </p>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p><code>alt-cmd-[</code> 折叠<br><code>alt-cmd-]</code> 展开<br><code>alt-cmd-shift-{</code> 折叠全部<br><code>alt-cmd-shift-}</code> 展开全部<br><code>cmd-k cmd-N</code> 指定折叠层级 N为层级数  </p>
<h2 id="文件语法高亮"><a href="#文件语法高亮" class="headerlink" title="文件语法高亮"></a>文件语法高亮</h2><p><code>ctrl-shift-L</code> 选择文本类型  </p>
<h2 id="使用Atom进行写作"><a href="#使用Atom进行写作" class="headerlink" title="使用Atom进行写作"></a>使用Atom进行写作</h2><p><code>ctrl-shift-M</code> Markdown预览<br>可用代码片段</p>
<blockquote>
<p>b, legal, img, l, i, code, t, table</p>
</blockquote>
<h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><p><code>cmd-alt-Z</code> checkout HEAD 版本<br><code>cmd-shift-B</code> 弹出untracked 和 modified文件列表<br><code>alt-g down</code> <code>alt-g up</code> 在修改处跳转<br><code>alt-G D</code> 弹出diff列表<br><code>alt-G O</code> 在github上打开文件<br><code>alt-G G</code> 在github上打开项目地址<br><code>alt-G B</code> 在github上打开文件blame<br><code>alt-G H</code> 在github上打开文件history<br><code>alt-G I</code> 在github上打开issues<br><code>alt-G R</code> 在github打开分支比较<br><code>alt-G C</code> 拷贝当前文件在gihub上的网址</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于CSS Transition,你需要知道的一切]]></title>
      <url>http://www.sevenhdu.space/2015/07/20/all-you-need-to-know-about-css-transitions/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：Alex MacCaw<br>原文地址：<a href="https://blog.alexmaccaw.com/css-transitions" target="_blank" rel="external">All you need to know about CSS Transitions</a></p>
</blockquote>
<p>CSS3的Transition能在Web页面构建出简单而又优雅的动画效果，不过再一次使用它的时候，仍然还有一些需要说明。<br>这篇文章中，我将探索一下transition中比较复杂的部分。，从链式过渡、事件到硬件加速以及动画函数。<br>让浏览器来控制动画序列，能优化性能，减少绘制，而且能将部分工作交给GPU处理。</p>
<a id="more"></a>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>目前，几乎所有版本的 Firefox, Safari, Chrome 包括 IE10 及以上版本都支持 transition 属性。即使浏览器不支持，属性也会立即应用，优雅降级。<br>动画与渐变特效在 Safari 和 Chrome 下仍然需要添加 -webkit 前缀，不过很快也会不需要了。</p>
<h2 id="应用过渡"><a href="#应用过渡" class="headerlink" title="应用过渡"></a>应用过渡</h2><p>可以使用CSS伪类来应用transition，例如<code>:hover</code>。使用时指定变化的属性名，过渡时间，以及其中一个默认动画函数，<code>linear</code>。</p>
<pre><code class="css">.element{
    height: 100px;
    transition: height 2s linear;
}

.element:hover{
    height: 200px;
}
</code></pre>
<p>当<code>:hover</code>伪类激活的时候，则元素的高度将在2秒以内从100px匀速过渡到200px。<br>浏览器默认过渡属性为 all （全部属性），动画函数为 ease，因此如果没特殊要求，只需定义变化的时间<br>用伪类来激活过渡效果，将有很多限制，很明显它不太灵活。解决方法就是用程序控制来添加、删除过渡类。</p>
<pre><code class="css">.element{
    opacity: 0;
    transform: scale(0.95) translate3d(0, 100%, 0);
    transition: transform 400s ease, opacity 400ms ease;
}

.element.active{
    opacity: 1;
    transform: scale(1) translate3d(0, 0, 0);
}

.element.inactive{
    opacity: 0;
    transform: scale(1) translate3d(0, 0, 0);
}
</code></pre>
<pre><code class="javascript">//js with jQuery
var active = fucntion(){
    $(&#39;.element&#39;).removeClass(&#39;inactive&#39;).addClass(&#39;active&#39;);
};

var inactive = function(){
    $(&#39;.element&#39;).removeClass(&#39;active&#39;).addClass(&#39;inactive&#39;);
}
</code></pre>
<p>上面的例子，有两个不同的过渡，激活时向上滑动，失效时淡出。JavaScript所做的事就是切换两个类<code>active</code>和<code>inactive</code>。</p>
<h2 id="过渡渐变"><a href="#过渡渐变" class="headerlink" title="过渡渐变"></a>过渡渐变</h2><p>不是所有的CSS属性都可以过渡，而且只能从一个绝对值变化到另一个绝对值。举个例子，<code>height</code>属性从<code>0px</code>到<code>atuo</code>将不会出现过渡效果。浏览器无法计算中间的过渡值，所以属性变化是瞬间的。Oli Studholme就列了下可过渡的<a href="http://oli.jp/2010/css-animatable-properties/" target="_blank" rel="external">属性列表</a>。</p>
<p>还有一个过渡会失效的属性是背景渐变（尽管纯背景颜色是支持的）。这个限制没有技术上的原因，只是还要等待一段时间来让浏览器实现对其的支持。</p>
<p>当然，还有一些好的变通方法。首先添加一个有透明度的渐变，然后过渡背景颜色。比如</p>
<pre><code class="css">.panel{
    background-color: #000;
    background-image: linear-gradient(rgba(255, 255, 0, 0.4), #FAFAFA);
    transition: background-color 400ms ease;
}
.panel:hover{
    background-color: #DDD
}
</code></pre>
<iframe height="265" scrolling="no" title="ZerLqj" src="//codepen.io/SevenHDU/embed/ZerLqj/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/ZerLqj/" target="_blank" rel="external">ZerLqj</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>如果渐变是连续不断的，则可以通过过渡<code>background-position</code>来达到效果。</p>
<iframe height="265" scrolling="no" title="peaRMK" src="//codepen.io/SevenHDU/embed/peaRMK/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/peaRMK/" target="_blank" rel="external">peaRMK</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>除此之外，还可以创建两个元素，一个覆盖另外一个，然后过渡他们的<code>opacity</code>属性。</p>
<pre><code class="css">.element {  
  width: 100px;  
  height: 100px;  
  position: relative;
  background: linear-gradient(#C7D3DC,#5B798E);    
}  

.element .inner {
  content: &#39;&#39;;
  position: absolute;
  left: 0; top: 0; right: 0; bottom: 0;
  background: linear-gradient(#DDD, #FAFAFA);          
  opacity: 0;
  transition: opacity 1s linear;
}

.element:hover .inner {
  opacity: 1;
}
</code></pre>
<p>但是，这样需要额外的标签，上一层的元素也会获取鼠标事件。所以，如果这里能用 <code>:before</code>，<code>:after</code> 伪类是最理想的，可惜目前只有 Firefox 支持伪类变化。Eliott Sprehn 正在努力让 webkit 也支持伪类变化，这一功能很快也会在 Safari Chrome 上实现。</p>
<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>过渡某些属性，比如<code>left</code>、<code>margin</code>，浏览器会在每一帧重新计算样式。会引起不必要的重绘，成本相当昂贵，尤其是有很多元素的时候。在移动设置上，这个后果更加明显。</p>
<p>解决方法就是交给GPU来处理，用CSS的<code>transform</code>就可以触发。简单地说，就是将元素转化为图片再执行过渡效果，避免任何样式的重计算，这就大大提高了性能。强制浏览器开启硬件加速最简单的方法就是用<code>transform: translate3d(0,0,0)</code>。</p>
<p>不过，这不是解决性能问题的完美方法，它本身也有问题。在必要的时候，才开启硬件加速，不要盲目用到每一个元素上。<br>举个例子，硬件加速会引起微妙的字体问题，比如<code>font</code>会损失<code>weight</code>。原因就是硬件加速过程中不会对字体启用抗锯齿特效，避免这个问题只能禁用 <code>font-smoothing: antialiased;</code>。</p>
<p>另外，不同的浏览器使用不同的硬件加速库，这可能引起跨浏览器问题。比如，Chrome和Safari都基于WebKit，不过Chrome使用Skia来处理图形渲染，Safari使用CoreGraphics。区别是细微，但却是实实在在存在的。</p>
<p>使用Chrome自带的开发者工具，展示了当前页面所有的重绘。在<code>about:flags</code>中启用Composited Render Layer Borders，就可以看到由GPU操纵的层。减少绘画的关键就是批处理更新DOM，而且尽可能交由GPU处理。</p>
<p>如果硬件加速在不同浏览器中有显示问题，比如闪烁或者颤抖，那就放弃使用<code>transform3d()</code>属性。</p>
<h2 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h2><p>为了充分利用GPU渲染能力，使用CSS的<code>transform</code>而不是类似<code>width</code>的属性来避免重新计算。假如要变化元素的width，你将会怎么做？答案是使用clipping（术语，only drawing things that will be visible to the viewer）。</p>
<p>下面的例子，搜索框会有两个过渡状态，</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-21/87876292-file_1490026519380_1f4c.png" alt=""></p>
<p>搜索框拉宽，使用<code>translate3d</code>属性使元素在X轴上拉长，而不是<code>width</code>。</p>
<pre><code class="css">.clipped {
  overflow: hidden;
  position: relative;
}

.clipped .clip {
  right: 0px;
  width: 45px;
  height: 45px;
  background: url(/images/clip.png) no-repeat
}

input:focus {
  -webkit-transform: translate3d(-50px, 0, 0);
}
</code></pre>
<p>这样每一帧都不会重新计算元素的宽度，过渡将更加平稳丝滑，性能更好。</p>
<h2 id="动画函数"><a href="#动画函数" class="headerlink" title="动画函数"></a>动画函数</h2><p>到目前为止，我们已经使用了一些浏览器预置的动画函数：<code>lienar</code>，<code>ease</code>，<code>ease-in</code>，<code>ease-out</code>，<code>ease-in-out</code>。更复杂的话就是使用cubic-bezier曲线自定义动画函数。例如</p>
<pre><code class="css">transition: -webkit-transform 1s cubic-bezier(0.17,0.67,0.69,1.33);
</code></pre>
<p>有两个现成工具，可以帮你使用cubic-bezier曲线自定义动画函数：<a href="http://easings.net/" target="_blank" rel="external">Pre-defined Curves</a>和<a href="http://cubic-bezier.com/" target="_blank" rel="external">Graphing Tool</a>。</p>
<h2 id="程序化过渡效果"><a href="#程序化过渡效果" class="headerlink" title="程序化过渡效果"></a>程序化过渡效果</h2><p>写CSS transition非常好，但有时候需要更好的控制，特别是链式过渡。我们不仅要通过JavaScript来调用，还要定义它们。</p>
<p>CSS transition中有一个神奇的all属性，保证了任何改变的属性都可以过渡（前提这个属性是可过渡的）。</p>
<pre><code class="javascript">var defaults = {
  duration: 400,
  easing: &#39;&#39;
};

$.fn.transition = function (properties, options) {
  options = $.extend({}, defaults, options);
  properties[&#39;webkitTransition&#39;] = &#39;all &#39; + options.duration + &#39;ms &#39; + options.easing;
  $(this).css(properties);
};
</code></pre>
<p>然后用 jQuery 函数 $.fn.transition 调用变化样式。</p>
<pre><code class="javascript">$(&#39;.element&#39;).transition({background: &#39;red&#39;});
</code></pre>
<h2 id="transiton回调"><a href="#transiton回调" class="headerlink" title="transiton回调"></a>transiton回调</h2><p>下一步就是使用transition回调。在基于WebKit的浏览器中，可以监听<code>webkitTransitionEnd</code>事件。其他浏览器，只要改下事件名称前缀也是可以的。</p>
<pre><code class="javascript">var callback = function () {
    // ...
}

$(this).one(&#39;webkitTransitionEnd&#39;, callback)
$(this).css(properties);
</code></pre>
<p>注意有时候事件不会触发，通知都是因为属性没有改变或者绘画没有触发。为了保证执行这个回调，可以在<code>setTimeout</code>中手动触发事件。</p>
<pre><code class="javascript">$.fn.emulateTransitionEnd = function(duration) {
    var called = false, $el = this;
    $(this).one(&#39;webkitTransitionEnd&#39;, function() { called = true; });
    var callback = function() {
        if (!called) $($el).trigger(&#39;webkitTransitionEnd&#39;);
    };
    setTimeout(callback, duration);
};
</code></pre>
<p>现在我们就可以在设置元素CSS之前滴啊用<code>$.fn.emulateTransitionEnd()</code>，保证过渡以及回调都能触发。</p>
<pre><code class="javascript">$(this).one(&#39;webkitTransitionEnd&#39;, callback);
$(this).emulateTransitionEnd(options.duration + 50);
$(this).css(properties);
</code></pre>
<h2 id="链式过渡"><a href="#链式过渡" class="headerlink" title="链式过渡"></a>链式过渡</h2><p>因此现在我们可以通过代码应用过渡，结束后执行回调，这样过渡效果就可以以排队的方式一个一个执行。而jQuery库中存在同样的方法。</p>
<p>针对队列，jQuery提供了两个主要的函数方法，<code>$.fn.queue(callback)</code>和<code>$.fn.dequeue()</code>。前者是将回调添加到队列中，而后者是执行队列中的下一项。</p>
<p>换句话说，我们需要在队列回调中设置CSS的过渡，当过渡完成时确保调用了<code>$.fn.dequeue</code>。</p>
<pre><code class="javascript">var $el = $(this);
$el.queue(function(){
    $el.one(&#39;webkitTransitionEnd&#39;, function(){
        $el.dequeue();
    });
    $el.css(properties);
});
</code></pre>
<p>这个例子很简单，让我们用jQuery的<code>delay()</code>函数来构建复杂的链式动画。</p>
<pre><code class="javascript">$(&#39;.element&#39;).transition({left: &#39;20px&#39;})
             .delay(200)
             .transition({background: &#39;red&#39;});
</code></pre>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>一般过渡时，是有两组CSS属性。从起始属性过渡到最终属性。</p>
<pre><code class="javascript">$(&#39;.element&#39;).css({left: &#39;10px&#39;})
             .transition({left: &#39;20px&#39;});
</code></pre>
<p>然后，你会发现当应用两组CSS属性，一组紧挨着一组，浏览器会尝试优化这些属性的变化，忽略初始的属性，阻止过渡变化。在后台，浏览器在重绘前批处理样式的变化，这样会加快渲染速度，但有时也有不利的影响。</p>
<p>解决办法是利用DOM元素的<code>offsetHeight</code>属性让浏览器在两套样式之间强制重绘。</p>
<pre><code class="javascript">$.fn.redraw = function(){
    $(this).each(function(){
        var redraw = this.offsetHeight;
    });
};
</code></pre>
<p>这个方法在大多数浏览器下都能吃工作正常，但在Android下就不行，可以使用timeout或者激活一个class。</p>
<pre><code class="javascript">$(&#39;.element&#39;).css({left: &#39;10px&#39;})
             .redraw()
             .transition({left: &#39;20px&#39;});
</code></pre>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>草案一直在积极的制定，而接下来的规格说明看起来真的很有希望。草种中包含新的Javascript API应对现在的局限性，给开发者更灵活的空间。</p>
<p>事实上，你可以在github上找到这些新API的(垫片)[<a href="https://github.com/web-animations/web-animations-js]。" target="_blank" rel="external">https://github.com/web-animations/web-animations-js]。</a></p>
<pre><code class="javascript">var anim = new Animation(elem, { left: &#39;100px&#39; }, 3);
anim.play();
</code></pre>
<p>使用这个API可以同步动画，提供个性化的动画函数，以及完成以后的回调。这都是令人相当兴奋的。</p>
<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2><p>目前为止，希望你已经深入的了解了CSS的<code>transition</code>属性，以及如何组合简单的API制作丰富的动画效果。</p>
<p>文中大多数js 例子来源于GFX，一个jQuery的CSS transtion库。里面内置了很多效果，例如滑动、爆炸、3D翻转。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS3中的transform]]></title>
      <url>http://www.sevenhdu.space/2015/06/15/CSS3-transform/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>transform可以对元素应用2D或3D变换，包括移动（translate）、缩放（scale）、倾斜（skew）、旋转（rotate）。通过transform可以实现很多动画效果。</p>
<a id="more"></a>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><table>
<thead>
<tr>
<th style="text-align:left">例子</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">translate(50px, 100px)</td>
<td style="text-align:right">元素向右平移50px,向下平移100px</td>
</tr>
<tr>
<td style="text-align:left">scale(2, 3)</td>
<td style="text-align:right">元素宽度扩大2倍，高度扩大3倍</td>
</tr>
<tr>
<td style="text-align:left">skew(20deg)</td>
<td style="text-align:right">元素在X轴倾斜20°</td>
</tr>
<tr>
<td style="text-align:left">rotate(60deg)</td>
<td style="text-align:right">元素顺时针旋转60°</td>
</tr>
</tbody>
</table>
<p>可以同一个元素使用多个不同类型的变换，只要变换之间以空格隔开</p>
<pre><code class="css">transform: translate(50px, 100px) scale(2, 3) rotate(60deg);
</code></pre>
<p>还有高级用法矩阵matrix，它可以将多个变换整合到一个变换函数中。<br>比如<br><code>rotate(45deg) translate(24px,25px)</code><br>对应<br><code>matrix(0.707107, 0.707107, -0.707107, 0.707107, -0.707107, 34.6482)</code><br>有这样一个转换的网站，可以自己试试看。<a href="http://meyerweb.com/eric/tools/matrix/" target="_blank" rel="external">传送门</a></p>
<p>想深入理解可以看看这篇文章<a href="http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/" target="_blank" rel="external">理解CSS3 transform中的Matrix(矩阵)</a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>直接上例子，为了让变换不那么生硬，加了过渡属性transition。</p>
<iframe height="265" scrolling="no" title="CSS3 transform" src="//codepen.io/SevenHDU/embed/YZxROr/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/SevenHDU/pen/YZxROr/" target="_blank" rel="external">CSS3 transform</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h2 id="transform-origin的玄机"><a href="#transform-origin的玄机" class="headerlink" title="transform-origin的玄机"></a>transform-origin的玄机</h2><p>transfrom属性和transform-origin是息息相关的。transform是以tranform-origin的值作为原点进行变换的，默认是中心点。<br>看下面的例子。</p>
<iframe height="300" scrolling="no" title="Transform-origin" src="//codepen.io/SevenHDU/embed/wJrggy/?height=300&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/wJrggy/" target="_blank" rel="external">Transform-origin</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h2 id="在桌面端和移动端用CSS开启硬件加速"><a href="#在桌面端和移动端用CSS开启硬件加速" class="headerlink" title="在桌面端和移动端用CSS开启硬件加速"></a>在桌面端和移动端用CSS开启硬件加速</h2><p>浏览器检测到元素应用某些CSS属性时，会开启硬件加速。其中一个就是3D变换。<br>例如</p>
<pre><code class="css">.ele {
   -webkit-transform: translate3d(250px,250px,250px)
   rotate3d(250px,250px,250px,-120deg)
   scale3d(0.5, 0.5, 0.5);
}
</code></pre>
<p>可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。</p>
<pre><code class="css">.ele {
   -webkit-transform: translateZ(0)
}
</code></pre>
<p>硬件加速在移动端尤其有用。<br>通过开启GPU硬件加速虽然可以提升动画渲染性能或解决一些棘手问题，但使用仍需谨慎，使用前一定要进行严谨的测试，否则它反而会大量占用浏览网页用户的系统资源，尤其是在移动端，肆无忌惮的开启GPU硬件加速会导致大量消耗设备电量，降低电池寿命等问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transforms/Using_CSS_transforms" target="_blank" rel="external">Using CSS transforms</a></li>
<li><a href="https://css-tricks.com/almanac/properties/t/transform/" target="_blank" rel="external">transform</a></li>
<li><a href="http://www.cnblogs.com/PeunZhang/p/3510083.html" target="_blank" rel="external">用CSS开启硬件加速来提高网站性能</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS选择器的优先级]]></title>
      <url>http://www.sevenhdu.space/2015/03/19/css-selectors-priority/</url>
      <content type="html"><![CDATA[<p>前几天面试的时候，被问到一个关于CSS选择器优先级的问题。</p>
<p>题目大概是这样的：<br>对以下CSS选择器进行排序：<br><a id="more"></a></p>
<ul>
<li>ID选择器</li>
<li>类选择器</li>
<li>元素选择器</li>
<li>属性选择器</li>
<li>伪类选择器</li>
<li>伪对象选择器</li>
<li>通配符选择器</li>
</ul>
<p>ID、类、标签这3个选择器的权重比较熟悉，其他几种选择器或多或少不是很确定。所以回来以后特地查了下<a href="https://www.w3.org/TR/CSS21/cascade.html#specificity" target="_blank" rel="external">W3C官网</a>，对CSS选择器优先级算是有了更深的认识。</p>
<p>CSS选择器通过a、b、c、d四个维度值来计算特征值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选择器类型</th>
<th style="text-align:right">维度（a,b,c,d）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">行内样式</td>
<td style="text-align:right">1,0,0,0</td>
</tr>
<tr>
<td style="text-align:left">ID选择器</td>
<td style="text-align:right">0,1,0,0</td>
</tr>
<tr>
<td style="text-align:left">类选择器、属性选择器、伪类选择器</td>
<td style="text-align:right">0,0,1,0</td>
</tr>
<tr>
<td style="text-align:left">元素选择器，伪元素选择器</td>
<td style="text-align:right">0,0,0,1</td>
</tr>
<tr>
<td style="text-align:left">通用元素选择器（*）</td>
<td style="text-align:right">0,0,0,0</td>
</tr>
</tbody>
</table>
<p>规则也很简单，同一维度比较个数，个数多的优先级高，相同个数则比较下一级的个数，全部都相同，则后定义的优先级高。不过如果属性中使用了!important，则优先级提高到最高。<br>因此，最后的结论就是<br><code>!important&gt;行内&gt;ID&gt;类、属性、伪类&gt;元素、伪元素&gt;通配符</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS中的伪类和伪元素]]></title>
      <url>http://www.sevenhdu.space/2015/03/05/css-pseudo-class-and-pseudo-elments/</url>
      <content type="html"><![CDATA[<p>先看<code>W3C</code>的定义<br>. <strong>CSS伪类</strong> 用于向某些选择器添加特殊的效果<br>. <strong>CSS伪元素</strong> 用于向某些选择器设置特殊效果</p>
<p>光看定义，其实还是云里雾里的，所以还是要深入研究下才能搞明白他们的作用。</p>
<a id="more"></a>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪类与类相似，但又没有类附加标签上。伪类分为UI伪类和结构化伪类。</p>
<h3 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h3><ul>
<li>:link(将样式添加到未被访问的链接上)</li>
<li>:visted(将样式已添加到访问的链接上)</li>
<li>:hover(将样式添加到鼠标悬浮的元素上)</li>
<li>:active(将样式添加到被激活的元素上)</li>
<li>:focus(将样式添加到被选中的元素上)</li>
</ul>
<h3 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h3><ul>
<li>:first-child(将样式添加到第一个子元素上)</li>
<li>:last-child(将样式添加到最后一个子元素上)</li>
</ul>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素是在文档中若有实无的元素。<br>主要有以下几种</p>
<ul>
<li>:first-letter(将样式添加到第一个字母)</li>
<li>:first-line(将样式添加到第一行)</li>
<li>:before(在某些元素前面插入某些内容)</li>
<li>:after(在某些元素后面插入某些内容)</li>
</ul>
<p>看到:after，大家脑子里应该都能想到那个经典的清除浮动的CSS的吧。没错，就是这个。</p>
<pre><code class="css">.clearfix:after {
    content:&quot;.&quot;;
    display:block;
    height:0;
    visibility:hidden;
    clear:both;
}
</code></pre>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p><strong>伪类的实现就好比给这个标签添加了一个虚拟的类。</strong><br>举个栗子</p>
<pre><code class="html">a:hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>若不用伪类，实现同样的效果，需要这么做</p>
<pre><code class="html">.hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>这么一对比，”伪类“的概念是不是清晰了很多。</p>
<p><strong>而伪元素则好比添加了一个新的标签。</strong></p>
<pre><code class="html">p:first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;Hello,World&lt;/p&gt;
</code></pre>
<p>若不用伪元素，实现同样的效果，需要添加一个额外的标签</p>
<pre><code class="html">.first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;&lt;span class=&quot;first-letter&quot;&gt;H&lt;/span&gt;ello,World&lt;/p&gt;
</code></pre>
<p>因此总结下区分的方法：<strong>现实相同效果是需要添加一个类还是一个元素标签。</strong></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>CSS3为了区别伪类和伪元素，明确使用单冒号来表示伪类，双冒号来表示伪元素。但为兼容性考虑，目前基本还是使用单冒号来表示。</li>
<li>搜索引擎不会搜索伪元素的信息。因此，不要通过伪元素添加你想让搜索引擎索引的重要内容</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解DOM事件流]]></title>
      <url>http://www.sevenhdu.space/2014/10/16/dom-event-flow/</url>
      <content type="html"><![CDATA[<p>当浏览器发展到第四代时（IE4和Netscape Communicator 4）,浏览器团队遇到一个很有意思的问题：页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面。<br>事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流。</p>
<a id="more"></a>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。看下面的例子</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>点击按钮，那么这个click事件会按照以下顺序传播：<br>1.input<br>2.div<br>3.body<br>4.html<br>5.document</p>
<p>虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获。</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。以前面的例子，则会按下图顺序触发事件。</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-15/54841141-file_1487127495480_10fd7.png" alt="事件流"></p>
<p>在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到div后就停止了。下一个阶段是处于目标阶段，于是事件在input上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。</p>
<p>多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上操作事件。  看如下例子。</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;wrap&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var wrap = document.getElementById(&quot;wrap&quot;);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;冒泡&quot;);
            }, false);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;捕获&quot;);
            }, true)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这个Demo的结果，应该很清楚了吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你必须了解的Session的本质]]></title>
      <url>http://www.sevenhdu.space/2014/09/22/you-must-know-the-nature-of-session/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：Chis<br>原文地址：<a href="http://shiflett.org/articles/the-truth-about-sessions" target="_blank" rel="external">The Truth about Sessions</a></p>
</blockquote>
<p>有一点我们必须承认，大多数web应用程序都离不开Session的使用。这篇文章将会结合php以及http协议来分析如何建立一个安全的会话管理机制。我们先简单的了解一些http的知识，从而理解该协议的无状态特性。然后，学习一些关于cookie的基本操作。最后，我会一步步阐述如何使用一些简单，高效的方法来提高你的php应用程序的安全性以及稳定行。</p>
<a id="more"></a>
<p>我想大多数的php初级程序员一定会认为php默认的Session机制的安全性似乎是有一定保障的，事实恰好相反。 php团队只是提供了一套便捷的Session的解决方案提供给程序员使用，至于安全性的话，应该由程序员来加强，这是应用程序开发团队的责任。因为，这里面的方法很多，可以这么说吧，没有最好，只有更好。攻击的方式在不断变化，防守方也需要不断变招，所以，我个人认为php团队的做法还是比较明智的。</p>
<h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>Http是一种无状态性的协议。这是因为此种协议不要求浏览器在每次请求中标明它自己的身份，并且浏览器以及服务器之间并没有保持一个持久性的连接用于多个页面之间的访问。当一个用户访问一个站点的时候，用户的浏览器发送一个http请求到服务器，服务器返回给浏览器一个http响应。其实很简单的一个概念，客户端一个请求，服务器端一个回复，这就是整个基于http协议的通讯过程。</p>
<p>因为web应用程序是基于http协议进行通讯的，而我们已经讲过了http是无状态的，这就增加了维护web应用程序状态的难度, 对于开发者来说，是一个不小的挑战。Cookies是作为http的一个扩展诞生的，其主要用途是弥补http的无状态特性，提供了一种保持客户端与服务器端之间状态的途径，但是由于出于安全性的考虑，有的用户在浏览器中是禁止掉Cookie的。这种情况下，状态信息只能通过url中的参数来传递到服务器端，不过这种方式的安全性很差。事实上，按照通常的想法，应该有客户端来表明自己的身份，从而和服务器之间维持一种状态，但是出于安全性方面的考虑，我们都应该明白一点 – 来自客户端的信息都是不能完全信任的。</p>
<p>尽管这样，针对维持web应用程序状态的问题，相对来说，还是有比较优雅的解决方案的。不过，应该说是没有完美的解决方案，再好的解决方案也不可能适用所有的情况。这篇文章将介绍一些技术。这些技术可以用来比较稳定地维持应用程序的状态以及抵御一些针对Session的攻击，比如会话劫持。并且你可以学习到cookie是怎样工作的，php 的Session做了那些事情，以及怎样才能劫持Session。</p>
<h2 id="HTTP-概览"><a href="#HTTP-概览" class="headerlink" title="HTTP 概览"></a>HTTP 概览</h2><p>如何才能保持web应用程序的状态以及选择最合适的解决方案呢?在回答这个问题之前，必须得先了解web的底层协议 – Hypertext Transfer Protocol (HTTP)。</p>
<p>当用户访问<code>http://example.com</code>这个域名的时候，浏览器就会自动和服务器建立TCP/IP连接，然后发送http请求到example.com的服务器的80端口。该个请求的语法如下所示：</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
</code></pre>
<p>以上第一行叫做请求行，第二个参数(一个反斜线在这个例子中)表示所请求资源的路径。反斜线代表了根目录;服务器会转换这个根目录为服务器文件系统中的一个具体目录。</p>
<p>Apache的用户常用DocumentRoot这个命令来设置这个文档根路径。如果请求的url是 <code>http://example.org/path/to/script.php</code>那么请求的路径就是<code>/path/to/script.php</code>。假如DocumentRoot被定义为<code>usr/lcoal/apache/htdocs</code>的话,整个请求的资源路径就是<code>/usr/local/apache/htdocs/path/to/script.php</code>。</p>
<p>第二行描述的是http头部的语法。在这个例子中的头部是Host, 它标识了浏览器希望获取资源的域名主机。还有很多其它的请求头部可以包含在http请求中，比如user-Agent头部，在php可以通过<code>$_SERVER[&#39;HTTP_USER_AGENT&#39;]</code>获取请求中所携带的这个头部信息。</p>
<p>但是遗憾的是，在这个请求例子中，没有任何信息可以唯一标识当前这个发出请求的客户端。有些开发者借助请求中的ip头部来唯一标识发出此次请求的客户端，但是这种方式存在很多问题。因为，有些用户是通过代理来访问的，比如用户A通过代理B连接网站www.example.com, 服务器端获取的IP信息是代理B分配给A的IP地址，如果用户这时断开代理，然后再次连接代理的话，它的代理IP地址又再次改变，也就说一个用户对应了多个IP地址，这种情况下，服务器端根据IP地址来标识用户的话，会认为请求是来自不同的用户，事实上是同一个用户。 还用另外一种情况就是，比如很多用户是在同一个局域网里通过路由连接互联网，然后都访问www.example.com的话，由于这些用户共享同一个外网IP地址，这会导致服务器认为这些用户是同一个用户发出的请求，因为他们是来自同一个IP地址的访问。</p>
<p>保持应用程序状态的第一步就是要知道如何来唯一地标识每个客户端。因为只有在http中请求中携带的信息才能用来标识客户端，所以在请求中必须包含某种可以用来标识客户端唯一身份的信息。Cookie设计出来就是用来解决这一问题的。</p>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>如果你把Cookies看成为http协议的一个扩展的话，理解起来就容易的多了，其实本质上cookies就是http的一个扩展。有两个http头部是专门负责设置以及发送cookie的,它们分别是Set-Cookie以及Cookie。当服务器返回给客户端一个http响应信息时，其中如果包含Set-Cookie这个头部时，意思就是指示客户端建立一个cookie，并且在后续的http请求中自动发送这个cookie到服务器端，直到这个cookie过期。如果cookie的生存时间是整个会话期间的话，那么浏览器会将cookie保存在内存中，浏览器关闭时就会自动清除这个cookie。另外一种情况就是保存在客户端的硬盘中，浏览器关闭的话，该cookie也不会被清除，下次打开浏览器访问对应网站时，这个cookie就会自动再次发送到服务器端。一个cookie的设置以及发送过程分为以下四步：</p>
<ol>
<li>客户端发送一个http请求到服务器端</li>
<li>服务器端发送一个http响应到客户端，其中包含Set-Cookie头部</li>
<li>客户端发送一个http请求到服务器端，其中包含Cookie头部</li>
<li>服务器端发送一个http响应到客户端</li>
</ol>
<p>这个通讯过程也可以用以下下示意图来描述：</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-22/22705650-file_1490113524728_11e4e.png" alt="通讯过程"></p>
<p>在客户端的第二次请求中包含的Cookie头部中，提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p>
<h2 id="Get、POST数据"><a href="#Get、POST数据" class="headerlink" title="Get、POST数据"></a>Get、POST数据</h2><p>除了cookies,客户端还可以将发送给服务器的数据包含在请求的url中，比如请求的参数或者请求的路径中。 我们来看一个例子：</p>
<pre><code class="HTTP">GET /index.php?foo=bar HTTP/1.1
Host: example.org
</code></pre>
<p>以上就是一个常规的http get 请求，该get请求发送到example.org域名对应的web 服务器下的index.php脚本, 在index.php脚本中，可以通过<code>$_GET[&#39;foo&#39;]</code>来获取对应的url中foo参数的值，也就是bar。大多数php开发者都称这样的数据会GET数据，也有少数称它为查询数据或者url变量。但是大家需要注意一点，不是说GET数据就只能包含在HTTP GET类型的请求中，在HTTP POST类型的请求中同样可以包含GET数据，只要将相关GET数据包含在请求的url中即可，也就是说GET数据的传递不依赖与具体请求的类型。</p>
<p>另外一种客户端传递数据到服务器端的方式是将数据包含在http请求的内容区域内。 这种方式需要请求的类型是POST的，看下面一个例子：</p>
<pre><code class="HTTP">POST /index.php HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded
Content-Length: 7
foo=bar
</code></pre>
<p>在这种情况下，在脚本index.php可以通过调用<code>$_POST[&#39;foo&#39;]</code>来获取对应的值bar。开发者称这个数据为POST数据,也就是大家熟知的form以post方式提交请求的方式。</p>
<p>在一个请求中，可以同时包含这两种形式的数据：</p>
<pre><code class="HTTP">POST /index.php?myget=foo HTTP/1.1
Host: example.orgContent-Type: application/x-www-form-urlencoded
Content-Length: 11
mypost=bar
</code></pre>
<p>这两种传递数据的方式，比起用cookies来传递数据更稳定，因为cookie可能被禁用，但是以GET以及POST方式传递数据时，不存在这种情况。我们可以将PHPSESSID包含在http请求的url中，就像下面的例子一样：</p>
<pre><code class="HTTP">GET /index.php?PHPSESSID=12345 HTTP/1.1
Host: example.org
</code></pre>
<p>以这种方式传递session id的话，可以跟用cookie头部传递session id一样，达到同样的效果， 但是，缺点就是需要开发者人为地将session id附加在url中或者作为隐藏字段加入到表单中。不像cookie一样，只要服务器端指示客户端创建cookie成功以后，客户端在后续的请求中，会自动第将对应的没有过期的cookie传递给服务器端。当然，php在开启session.use_trans_sid后，也可以自动地将session id 附加在url中以及表单的隐藏字段中，但是这个选项不建议开启，因为存在安全问题。这样的话，容易泄露session id, 比如有的用户会bookmark一个url或者分享一个url，那么session id也就暴露了，加入这个session id还没有过期，那是有一定的安全问题存在的，除非服务器端，除了session id外，还附加了其它方式进行验证用户的合法性!</p>
<p>尽管以POST的方式来传递session id的话，相对GET的方式来说，会安全的多。但是，这种方式的缺点就是比较麻烦，因为这样的话，在你的应用程序中比较将所有的请求都转换成post的请求，这显然是不太合适的。</p>
<h2 id="Session的管理"><a href="#Session的管理" class="headerlink" title="Session的管理"></a>Session的管理</h2><p>直到现在，我只讨论了如何维护应用程序的状态，只是简单地涉及到了如果保持请求之间的关系。接下来，我阐述下在实际中用到比较多的技术 – Session的管理。涉及到session的管理，就不是单单地维持各个请求之间的状态，还需要维持会话期间针对每个特定用户使用到的数据。我们常常把这种数据叫做session数据，因为这些数据是跟某个特定用户与服务器之间的会话相关联的。如果你使用php内置的session的管理机制，那么session数据一般是保存在/tmp这个服务器端的文件夹中，并且其中的session数据会被自动地保存到超级数组<code>$_SESSION</code>中。一个最简单的使用session的例子，就是将相关的session数据从一个页面传递(注意：实际传递的是session id)到另一个页面。下面用示例代码1, start.php, 对这个例子加以演示：</p>
<pre><code class="php">&lt;?php
    session_start();
    $_SESSION[&quot;foo&quot;] = &quot;bar&quot;;
?&gt;
&lt;a href=&quot;continue.php&quot;&gt;continue.php&lt;/a&gt;
</code></pre>
<p>假如用户点击start.php中的链接访问continue.php,那么在continue.php中就可以通过<code>$_SESSION[&#39;foo&#39;]</code>获取在start.php中的定义的值’bar’。看下面的示例代码2:</p>
<p>示例代码2 – continue.php</p>
<pre><code class="php">&lt;?php
    session_start();
    echo $_SESSION[&quot;foo&quot;];
?&gt;
</code></pre>
<p>是不是非常简单，但是我要指出的话，如果你真的这样来写代码的话，说明你对php底层的对于session的实现机制还不是非常了解透彻。在不了解php内部给你自动做了多少事情的情况下，你会发现如果程序出错的话，这样的代码将变的很难调试，事实上，这样的代码也完全没有安全性可言。</p>
<h2 id="Session的安全问题"><a href="#Session的安全问题" class="headerlink" title="Session的安全问题"></a>Session的安全问题</h2><p>一直以来很多开发者都认为php内置的session管理机制是具有一定的安全性，可以对一般的session攻击起到防御。事实上，这是一种误解，php团队只实现了一种方便有效的机制。具体的安全措施，应该有应用程序的开发团队来实施。 就像开篇谈到的，没有最好的解决方案，只有最合适你的方案。</p>
<p>现在，我们来看下一个比较常规的针对session的攻击：<br>用户访问<code>http://www.example.org</code>，并且登录。<br>example.org的服务器设置指示客户端设置相关cookie – PHPSESSID=12345<br>攻击者这时访问<code>http://www.example.org/</code>,并且在请求中携带了对应的cookie,PHPSESSID=12345<br>这样情况下，因为example.org的服务器通过PHPSESSID来辨认对应的用户的，所以服务器错把攻击者当成了合法的用户。<br>整个过程的描述，请看下面的示例图：</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-22/74705136-file_1490114069937_d197.png" alt="Session攻击"></p>
<p>当然这种攻击的方式，前提条件是攻击者必须通过某种手段固定，劫持或者猜测出某个合法用户的PHPSESSID。虽然这看起来难度很高，但是也不是不可能的事情。</p>
<h2 id="安全性的加强"><a href="#安全性的加强" class="headerlink" title="安全性的加强"></a>安全性的加强</h2><p>有很多技术可以用来加强Session的安全性，主要思想就是要使验证的过程对于合法用户来说，越简单越好，然后对于攻击者来说，步骤要越复杂越好。当然，这似乎是比较难于平衡的，要根据你应用程序的具体设计来做决策。</p>
<p>最简单的基于HTTP/1.1请求包括请求行以及一些Host的头部：</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
</code></pre>
<p>如果客户端通过PHPSESSID传递相关的session标识符，可以将PHPSESSID放在cookie头部中进行传递:</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
Cookie: PHPSESSID=12345
</code></pre>
<p>同样地，客户端也可以将session标识符放在请求的url中进行传递。</p>
<pre><code class="HTTP">GET /?PHPSESSID=12345 HTTP/1.1
Host: example.org
</code></pre>
<p>当然，session标识符也可以包含在POST数据中，但是这对用户体验有影响，所以这种方式很少采用。</p>
<p>因为来自TCP/IP信息也不一定可以完全信任的，所以，对于web开发者来说，利用TCP/IP中的信息来加强安全性也是不太合适的。 不过，攻击者也必须提供一个合法用户的唯一的标识符，才能假扮成合法用户进入系统。因此，看起来唯一能够有效的保护系统的措施，就是尽量地隐藏session标识符或者使之难于猜测出来。最好就是两者都能实施。</p>
<p>PHP会自动生成一个随机的session ID，基本来说是不可能被猜测出来的，所以这方面的安全还是有一定保障的。但是，要防止攻击者获取一个合法的session ID是相当困难的，这基本上不是开发者所能控制的。</p>
<p>事实上，许多情况下都有可能导致session ID的泄露。 比如说，如果通过GET数据来传递session ID的话，就有可能暴露这个敏感的身份信息。因为，有的用户可能会将带有session ID的链接缓存，收藏或者发送在邮件内容中。Cookies是一种相对来说安全一点的机制，但是用户是可以在客户端中禁止掉cookies的。在一些IE的版本中也有比较严重的安全漏洞，比较有名的就是会泄露cookies给一些有安全隐患的邪恶站点。</p>
<p>因此，作为一个开发者，可以肯定session ID是不能被猜测出来的，但是还是有可能被攻击者使用某些方法获取到。所以，必须采取一些额外的安全措施来防止此类情况在你的应用程序中发生。</p>
<p>实际上，一个标准的HTTP请求中除了Host等必须包含的头部，还包含了一些可选的头部.举一个例子，看下面的一个请求：</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
Cookie: PHPSESSID=12345
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1
Accept: text/html;q=0.9, */*;q=0.1
Accept-Charset: ISO-8859-1, utf-8;q=0.66, *;q=0.66
Accept-Language: en
</code></pre>
<p>我们可以看到，在以上的一个请求例子中包含了四个额外的头部，分别是User-Agent, Accept, Accept-Charset以及Accept-Language。因为这些头部不是必须的，所以完全依赖他们在你的应用程序中发挥作用是不太明智的。但是，如果一个用户的浏览器确实发送了这些头部到服务器，那么可以肯定的是在接下来的同一个用户通过同一个浏览器发送的请求中，必然也会携带这些头部。当然，这其中也会有极少数的特殊情况发生。假如以上例子是由一个当前的跟服务器建立了会话的用户发出的请求，考虑下面的一个请求：</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
Cookie: PHPSESSID=12345
User-Agent: Mozilla/5.0
</code></pre>
<p>因为有相同的session id包含在请求的Cookie头部中，所以相同的PHPSESSION将会被访问到。但是，请求里的User-Agent头部跟先前的请求中的信息是不同的，系统是否可以假定这两个请求是同一个用户发出的?</p>
<p>像这种情况下，发现浏览器的头部改变了，但是不能肯定这是否是一次来自攻击者的请求的话，比较好的措施就是弹出一个要求输入密码的输入框让用户输入，这样的话，对用户体验的影响不会很大，又能很有效地防止攻击。</p>
<p>当然，你可以在系统中加入核查User-Agent头部的代码，类似示例3中的代码：</p>
<p>示例代码3</p>
<pre><code class="php">&lt;?php  
    session_start();  
    if (md5($_SERVER[&#39;HTTP_USER_AGENT&#39;]) != $_SESSION[&#39;HTTP_USER_AGENT&#39;])  
    {
        /* 弹出密码输入框 */
        exit;
    }  
?&gt;
</code></pre>
<p>当然，你先必须在第一次请求时，初始化session的时候，用MD5算法加密user agent信息并且保存在session中，类似下面示例4中的代码：</p>
<p>示例代码4</p>
<pre><code class="php">&lt;?php  
    session_start();  
    $_SESSION[&#39;HTTP_USER_AGENT&#39;] = md5($_SERVER[&#39;HTTP_USER_AGENT&#39;]);  
?&gt;
</code></pre>
<p>虽然不一定需要用MD5来加密这个User-Agent信息，但使用这种方式以后就不需要再过滤这个<code>$_SERVER[&#39;HTTP_USER_AGENT&#39;]</code>数据了。不然的话，在使用这个数据以前必须要进行数据过滤，因为任何来自客户端的数据都是不可信任的，必须要注意这一点。</p>
<p>在你检查这个User-Agent客户端头部信息以后，做为一个攻击者必须要完成两步才能劫持一个session:</p>
<ol>
<li>获取一个合法的session id</li>
<li>包含一个相同的User-Agent头部在伪造的请求中</li>
</ol>
<p>你可能会说，居然攻击者能获得有效的session id,那么以他的水平，伪造一个相同的User-Agent不是件难事。不错，但是我们可以说这至少给他添加了一些麻烦，在一定程度上也增加了session机制的安全性。</p>
<p>你应该也能想到了，既然我们可以检查User-Agent这个头部来加强安全性，那么不妨再利用其它的一些头部信息，把他们组合起来生成一个加密的token，并且让客户端在后续的请求中携带这个token!这样的话，攻击者基本上不可能猜测出这样一个token是怎么生成出来的。这好比你用信用卡在超市付款，一个你必须有信用卡(好比session id)，另外你也必须输入一个支付密码(好比token),这有这两者都符合的情况下，你才能成功进入账号付款。 看下面一段代码：</p>
<pre><code class="php">&lt;?php  
    session_start();  
    $token = &#39;SHIFLETT&#39; . $_SERVER[&#39;HTTP_USER_AGENT&#39;];
    $_SESSION[&#39;token&#39;] = md5($token . session_id());  
?&gt;
</code></pre>
<p>在你的验证机制中加入了这个非常难于猜测出来的token以后，安全性会得到很大的提升。假如这个token通过像session id一样的方式来进行传递，这种情况下，一个攻击者必须完成必要的3步来劫持用户的session:</p>
<ol>
<li>获取一个合法的session ID</li>
<li>在请求中加入相同的User-Agent头部,用与生成token</li>
<li>在请求中携带被攻击者的token</li>
</ol>
<p>这里面有个问题。如果session id以及token都是通过GET数据来传递的话，那么对于能获取session ID的攻击者，同样就能够获取到这个token。所以，比较安全靠谱的方式应该是利用两种不同的数据传递方式来分别传递session id以及token。例如，通过cookie来传递session id,然后通过GET数据来传递token。因此，假如攻击者通过某种手段获得了这个唯一的用户身份标识，也是不太可能同时轻松地获取到这个token，它相对来说依然是安全的</p>
<p>还有很多的技术手段可以用来加强你的session机制的安全性。希望你在大致了解session的内部本质以后，可以设计出适合你的应用系统的验证机制，从而大大的提高系统的安全性。毕竟，你是最熟悉当下你开发的系统的开发者之一，可以根据实际情况来实施一些特有的，额外的安全措施。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上只是大概地描述了session的工作机制，以及简单地阐述了一些安全措施。但要记住，以上的方法都是能够加强安全性，不是说能够完全保护你的系统，希望读者自己再去调研相关内容。在这个调研过程中，相信你会学到很有实际使用价值的方案。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DB2日期分组计算数据值]]></title>
      <url>http://www.sevenhdu.space/2014/08/18/DB2-sum-groupby/</url>
      <content type="html"><![CDATA[<p>最近参与的项目进行了一次优化技改，对其中SQL参数化公用方法进行了改造。又因项目组人员调整，接手其他模块。</p>
<p>在其他模块测试过程发现，一个针对日期分组计算的SQL报错，报SQL语句超长的异常。</p>
<a id="more"></a>
<p>举个栗子，功能要求如下：</p>
<p>表TABLE_TEST中</p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:center">AMOUNT</th>
<th style="text-align:right">CREATE_DATE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-01</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-09</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-11</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-21</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-24</td>
</tr>
</tbody>
</table>
<p>需求是从表中按CREAT_DATE每10天作为一个分组，统计总金额</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>之前的SQL是这样子的</p>
<pre><code class="SQL">SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-01&#39; AND &#39;2014-01-10&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-11&#39; AND &#39;2014-01-20&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-21&#39; AND &#39;2014-01-30&#39;
</code></pre>
<p>这个SQL主要有两方面问题，一方面程序逻辑发杂，需要算计每10天时间间隔的起始日期，还有一个方面是SQL语句冗长，如果日期跨度大的话，SQL语句就回相当长，直接导致程序抛异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>改进的SQL</p>
<pre><code class="SQL">SELECT SUM(AMOUNT) AS TOTALAMOUNT , (days(CREATE_DATE)-days(&#39;2014-01-01&#39;))/10 AS TIMESAPN
FROM TABLE_TEST GROUP BY TIMESAPN
</code></pre>
<p>关键部分在于  <strong>(days(CREATE_DATE)-days(‘2014-01-01’))/10 AS TIMESAPN</strong></p>
<p>TIMESAPN为0则表示该记录在第一个10天周期内，为1表示在第二个10天周期内，以此类推，最后以此字段作为分组条件，就可以达到上面SQL同样的效果。</p>
]]></content>
    </entry>
    
  
  
</search>
