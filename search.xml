<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[如何在移动端触发手机拨打电话]]></title>
      <url>http://www.sevenhdu.space/2017/03/15/make-call-in-mobile/</url>
      <content type="html"><![CDATA[<p>在移动端的项目中，经常会有这样的需求，点击按钮触发手机拨打电话。<br><a id="more"></a><br>这个需求其实很简单，按照下面的写法其实就可以实现。</p>
<pre><code class="html">&lt;a href=&quot;tel:10086&quot;&gt;拨打电话&lt;/a&gt;
</code></pre>
<p>而最近遇到的需求是电话号码动态变化的，因此想着能不能通过js来动态触发这个动作。搜了一下果然是有方法的。</p>
<pre><code class="javascript">function makeCall(telNo){
    window.location.href = &quot;tel:&quot; + telNo;
}
</code></pre>
<p>亲测，在IOS中微信、Safari、UC以及Android中的微信、UC均可触发拨打电话效果。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo]]></title>
      <url>http://www.sevenhdu.space/2016/09/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决在IOS下无法自动播放音频的问题]]></title>
      <url>http://www.sevenhdu.space/2016/09/21/autoplay-auido-in-ios/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道在IOS下H5页面是无法自动播放音频，必须通过用户交互比如点击等才能播放音频。IOS是为了防止偷跑流量才这么做的。但是很多H5项目中播放背景音频是一个很习以为常的需求。那该怎么办呢？答案就在微信的WeixinJSBridgeReady事件。</p>
<a id="more"></a>
<blockquote>
<p>JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action.</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>WeixinJSBridgeReady是微信自带的事件，只要监听这个事件，在执行函数里播放音频，就可以实现在微信中自动播放音频的功能。（毕竟微信渠道的量大，一定要保证微信是可以正常播放音频）</p>
<pre><code class="html">&lt;audio src=&quot;bgAudio.mp3&quot; id=&quot;bgAudio&quot; preload loop=&quot;loop&quot;&gt;&lt;/audio&gt;
</code></pre>
<pre><code class="javascript">function playBgAudio(){
    var bgAudio = document.getElementById(&quot;bgAudio&quot;);
    bgAudio.play();

    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function(){
        bgAudio.play();
    }, false);
}
</code></pre>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>很多同学发现用了上面的代码也没什么卵用，因为这里面还有个坑。上面的代码必须放在WeixinJSBridgeReady执行以前，如果WeixinJSBridgeReady事件都执行，再监听就没什么用了。<strong><em>所以监听的js代码一定要放在head前面，以确保最先执行</em></strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[fixed定位元素在设置了transform属性父元素下失效]]></title>
      <url>http://www.sevenhdu.space/2016/09/17/position-fixed-not-work-in-transform/</url>
      <content type="html"><![CDATA[<p>最近项目开发中遇到了一个奇怪的现象，<code>position:fixed</code>设置元素竟然不相对浏览器定位。最后发现原来是transform捣的鬼。<br>当fixed元素作为transform元素的资源时，<code>position:fixed</code>固定效果将失效，降级成类似<code>position:absolute</code>的表现。</p>
<a id="more"></a>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><iframe height="265" scrolling="no" title="jBaKqW" src="//codepen.io/SevenHDU/embed/jBaKqW/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/SevenHDU/pen/jBaKqW/" target="_blank" rel="external">jBaKqW</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>看完上面的例子，应该就清晰很多了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/" target="_blank" rel="external">CSS3 transform对普通元素的N多渲染影响</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Atom编辑器快捷键大全]]></title>
      <url>http://www.sevenhdu.space/2016/03/24/Atom-shortcut-keys/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：futantan<br>原文地址：<a href="https://github.com/futantan/atom" target="_blank" rel="external">https://github.com/futantan/atom</a></p>
</blockquote>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-24/13908820-file_1487866405842_16c03.png" alt=""></p>
<a id="more"></a>
<h2 id="文件切换"><a href="#文件切换" class="headerlink" title="文件切换"></a>文件切换</h2><p><code>ctrl-shift-s</code>  保存所有打开的文件<br><code>cmd-shift-o</code>  打开目录<br><code>cmd-\</code>   显示或隐藏目录树<br><code>ctrl-0</code>   焦点移到目录树<br>目录树下，使用a，m，delete来增加，修改和删除<br><code>cmd-t</code>或<code>cmd-p</code> 查找文件<br><code>cmd-b</code> 在打开的文件之间切换<br><code>cmd-shift-b</code> 只搜索从上次git commit后修改或者新增的文件</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>（等价于上下左右）<br><code>ctrl-p</code> 前一行<br><code>ctrl-n</code> 后一行<br><code>ctrl-f</code> 前一个字符<br><code>ctrl-b</code> 后一个字符  </p>
<p><code>alt-B</code>, <code>alt-left</code> 移动到单词开始<br><code>alt-F</code>, <code>alt-right</code> 移动到单词末尾  </p>
<p><code>cmd-right</code>, <code>ctrl-E</code> 移动到一行结束<br><code>cmd-left</code>, <code>ctrl-A</code>  移动到一行开始  </p>
<p><code>cmd-up</code> 移动到文件开始<br><code>cmd-down</code> 移动到文件结束  </p>
<p><code>ctrl-g</code> 移动到指定行 row:column 处</p>
<p><code>cmd-r</code> 在方法之间跳转</p>
<h2 id="目录树操作"><a href="#目录树操作" class="headerlink" title="目录树操作"></a>目录树操作</h2><p><code>cmd-\</code> 或者 <code>cmd-k cmd-b</code> 显示(隐藏)目录树<br><code>ctrl-0</code> 焦点切换到目录树(再按一次或者<code>Esc</code>退出目录树)<br><code>a</code> 添加文件<br><code>d</code> 将当前文件另存为(duplicate)<br><code>i</code> 显示(隐藏)版本控制忽略的文件<br><code>alt-right</code> 和 <code>alt-left</code> 展开(隐藏)所有目录<br><code>ctrl-al-]</code> 和 <code>ctrl-al-[</code> 同上<br><code>ctrl-[</code> 和 <code>ctrl-]</code> 展开(隐藏)当前目录<br><code>ctrl-f</code> 和 <code>ctrl-b</code> 同上<br><code>cmd-k h</code> 或者 <code>cmd-k left</code> 在左半视图中打开文件<br><code>cmd-k j</code> 或者 <code>cmd-k down</code> 在下半视图中打开文件<br><code>cmd-k k</code> 或者 <code>cmd-k up</code> 在上半视图中打开文件<br><code>cmd-k l</code> 或者 <code>cmd-k right</code> 在右半视图中打开文件<br><code>ctrl-shift-C</code> 复制当前文件绝对路径</p>
<h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p><code>cmd-F2</code> 在本行增加书签<br><code>F2</code> 跳到当前文件的下一条书签<br><code>shift-F2</code> 跳到当前文件的上一条书签<br><code>ctrl-F2</code> 列出当前工程所有书签  </p>
<h2 id="选取"><a href="#选取" class="headerlink" title="选取"></a>选取</h2><blockquote>
<p>大部分和导航一致，只不过加上shift  </p>
</blockquote>
<p><code>ctrl-shift-P</code>  选取至上一行<br><code>ctrl-shift-N</code>  选取至下一样<br><code>ctrl-shift-B</code>  选取至前一个字符<br><code>ctrl-shift-F</code>  选取至后一个字符<br><code>alt-shift-B</code>, <code>alt-shift-left</code>  选取至字符开始<br><code>alt-shift-F</code>, <code>alt-shift-right</code>  选取至字符结束<br><code>ctrl-shift-E</code>, <code>cmd-shift-right</code>  选取至本行结束<br><code>ctrl-shift-A</code>, <code>cmd-shift-left</code>  选取至本行开始<br><code>cmd-shift-up</code>  选取至文件开始<br><code>cmd-shift-down</code>  选取至文件结尾<br><code>cmd-A</code>  全选<br><code>cmd-L</code>  选取一行，继续按回选取下一行<br><code>ctrl-shift-W</code>  选取当前单词  </p>
<h2 id="编辑和删除文本"><a href="#编辑和删除文本" class="headerlink" title="编辑和删除文本"></a>编辑和删除文本</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>ctrl-T</code> 使光标前后字符交换<br><code>cmd-J</code> 将下一行与当前行合并<br><code>ctrl-cmd-up</code>, <code>ctrl-cmd-down</code> 使当前行向上或者向下移动<br><code>cmd-shift-D</code> 复制当前行到下一行<br><code>cmd-K</code>, <code>cmd-U</code> 使当前字符大写<br><code>cmd-K</code>, <code>cmd-L</code> 使当前字符小写<br><code>cmd-shift-P</code> 搜索命令  </p>
<h3 id="删除和剪切"><a href="#删除和剪切" class="headerlink" title="删除和剪切"></a>删除和剪切</h3><p><code>ctrl-shift-K</code> 删除当前行<br><code>cmd-backspace</code> 删除到当前行开始<br><code>cmd-fn-backspace</code> 删除到当前行结束<br><code>ctrl-K</code> 剪切到当前行结束<br><code>alt-backspace</code> 或 <code>alt-H</code> 删除到当前单词开始<br><code>alt-delete</code> 或 <code>alt-D</code> 删除到当前单词结束  </p>
<h3 id="多光标和多处选取"><a href="#多光标和多处选取" class="headerlink" title="多光标和多处选取"></a>多光标和多处选取</h3><p><code>cmd-click</code> 增加新光标<br><code>cmd-shift-L</code> 将多行选取改为多行光标<br><code>ctrl-shift-up</code>, <code>ctrl-shift-down</code> 增加上（下）一行光标<br><code>cmd-D</code> 选取文档中和当前单词相同的下一处<br><code>ctrl-cmd-G</code> 选取文档中所有和当前光标单词相同的位置  </p>
<h3 id="括号跳转"><a href="#括号跳转" class="headerlink" title="括号跳转"></a>括号跳转</h3><p><code>ctrl-m</code> 相应括号之间，html tag之间等跳转<br><code>ctrl-cmd-m</code> 括号(tag)之间文本选取<br><code>alt-cmd-.</code> 关闭当前XML/HTML tag  </p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p><code>ctrl-shift-U</code> 调出切换编码选项  </p>
<h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><p><code>cmd-F</code> 在buffer中查找<br><code>cmd-shift-f</code> 在整个工程中查找  </p>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p><code>alt-shift-S</code> 查看当前可用代码片段  </p>
<blockquote>
<p>在<code>~/.atom</code>目录下<code>snippets.cson</code>文件中存放了你定制的snippets  </p>
</blockquote>
<p><a href="https://atom.io/docs/v1.0.0/using-atom-snippets" target="_blank" rel="external">定制说明</a>  </p>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p><code>ctrl-space</code> 提示补全信息  </p>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p><code>alt-cmd-[</code> 折叠<br><code>alt-cmd-]</code> 展开<br><code>alt-cmd-shift-{</code> 折叠全部<br><code>alt-cmd-shift-}</code> 展开全部<br><code>cmd-k cmd-N</code> 指定折叠层级 N为层级数  </p>
<h2 id="文件语法高亮"><a href="#文件语法高亮" class="headerlink" title="文件语法高亮"></a>文件语法高亮</h2><p><code>ctrl-shift-L</code> 选择文本类型  </p>
<h2 id="使用Atom进行写作"><a href="#使用Atom进行写作" class="headerlink" title="使用Atom进行写作"></a>使用Atom进行写作</h2><p><code>ctrl-shift-M</code> Markdown预览<br>可用代码片段</p>
<blockquote>
<p>b, legal, img, l, i, code, t, table</p>
</blockquote>
<h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><p><code>cmd-alt-Z</code> checkout HEAD 版本<br><code>cmd-shift-B</code> 弹出untracked 和 modified文件列表<br><code>alt-g down</code> <code>alt-g up</code> 在修改处跳转<br><code>alt-G D</code> 弹出diff列表<br><code>alt-G O</code> 在github上打开文件<br><code>alt-G G</code> 在github上打开项目地址<br><code>alt-G B</code> 在github上打开文件blame<br><code>alt-G H</code> 在github上打开文件history<br><code>alt-G I</code> 在github上打开issues<br><code>alt-G R</code> 在github打开分支比较<br><code>alt-G C</code> 拷贝当前文件在gihub上的网址</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于CSS Transition,你需要知道的一切]]></title>
      <url>http://www.sevenhdu.space/2015/07/20/all-you-need-to-know-about-css-transitions/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：Alex MacCaw<br>原文地址：<a href="https://blog.alexmaccaw.com/css-transitions" target="_blank" rel="external">All you need to know about CSS Transitions</a></p>
</blockquote>
<p>CSS3的Transition能在Web页面构建出简单而又优雅的动画效果，不过再一次使用它的时候，仍然还有一些需要说明。<br>这篇文章中，我将探索一下transition中比较复杂的部分。，从链式过渡、事件到硬件加速以及动画函数。<br>让浏览器来控制动画序列，能优化性能，减少绘制，而且能将部分工作交给GPU处理。</p>
<a id="more"></a>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>目前，几乎所有版本的 Firefox, Safari, Chrome 包括 IE10 及以上版本都支持 transition 属性。即使浏览器不支持，属性也会立即应用，优雅降级。<br>动画与渐变特效在 Safari 和 Chrome 下仍然需要添加 -webkit 前缀，不过很快也会不需要了。</p>
<h2 id="应用过渡"><a href="#应用过渡" class="headerlink" title="应用过渡"></a>应用过渡</h2><p>可以使用CSS伪类来应用transition，例如<code>:hover</code>。使用时指定变化的属性名，过渡时间，以及其中一个默认动画函数，<code>linear</code>。</p>
<pre><code class="css">.element{
    height: 100px;
    transition: height 2s linear;
}

.element:hover{
    height: 200px;
}
</code></pre>
<p>当<code>:hover</code>伪类激活的时候，则元素的高度将在2秒以内从100px匀速过渡到200px。<br>浏览器默认过渡属性为 all （全部属性），动画函数为 ease，因此如果没特殊要求，只需定义变化的时间<br>用伪类来激活过渡效果，将有很多限制，很明显它不太灵活。解决方法就是用程序控制来添加、删除过渡类。</p>
<pre><code class="css">.element{
    opacity: 0;
    transform: scale(0.95) translate3d(0, 100%, 0);
    transition: transform 400s ease, opacity 400ms ease;
}

.element.active{
    opacity: 1;
    transform: scale(1) translate3d(0, 0, 0);
}

.element.inactive{
    opacity: 0;
    transform: scale(1) translate3d(0, 0, 0);
}
</code></pre>
<pre><code class="javascript">//js with jQuery
var active = fucntion(){
    $(&#39;.element&#39;).removeClass(&#39;inactive&#39;).addClass(&#39;active&#39;);
};

var inactive = function(){
    $(&#39;.element&#39;).removeClass(&#39;active&#39;).addClass(&#39;inactive&#39;);
}
</code></pre>
<p>上面的例子，有两个不同的过渡，激活时向上滑动，失效时淡出。JavaScript所做的事就是切换两个类<code>active</code>和<code>inactive</code>。</p>
<h2 id="过渡渐变"><a href="#过渡渐变" class="headerlink" title="过渡渐变"></a>过渡渐变</h2><p>不是所有的CSS属性都可以过渡，而且只能从一个绝对值变化到另一个绝对值。举个例子，<code>height</code>属性从<code>0px</code>到<code>atuo</code>将不会出现过渡效果。浏览器无法计算中间的过渡值，所以属性变化是瞬间的。Oli Studholme就列了下可过渡的<a href="http://oli.jp/2010/css-animatable-properties/" target="_blank" rel="external">属性列表</a>。</p>
<p>还有一个过渡会失效的属性是背景渐变（尽管纯背景颜色是支持的）。这个限制没有技术上的原因，只是还要等待一段时间来让浏览器实现对其的支持。</p>
<p>当然，还有一些好的变通方法。首先添加一个有透明度的渐变，然后过渡背景颜色。比如</p>
<pre><code class="css">.panel{
    background-color: #000;
    background-image: linear-gradient(rgba(255, 255, 0, 0.4), #FAFAFA);
    transition: background-color 400ms ease;
}
.panel:hover{
    background-color: #DDD
}
</code></pre>
<iframe height="265" scrolling="no" title="ZerLqj" src="//codepen.io/SevenHDU/embed/ZerLqj/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/ZerLqj/" target="_blank" rel="external">ZerLqj</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>如果渐变是连续不断的，则可以通过过渡<code>background-position</code>来达到效果。</p>
<iframe height="265" scrolling="no" title="peaRMK" src="//codepen.io/SevenHDU/embed/peaRMK/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/peaRMK/" target="_blank" rel="external">peaRMK</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>除此之外，还可以创建两个元素，一个覆盖另外一个，然后过渡他们的<code>opacity</code>属性。</p>
<pre><code class="css">.element {  
  width: 100px;  
  height: 100px;  
  position: relative;
  background: linear-gradient(#C7D3DC,#5B798E);    
}  

.element .inner {
  content: &#39;&#39;;
  position: absolute;
  left: 0; top: 0; right: 0; bottom: 0;
  background: linear-gradient(#DDD, #FAFAFA);          
  opacity: 0;
  transition: opacity 1s linear;
}

.element:hover .inner {
  opacity: 1;
}
</code></pre>
<p>但是，这样需要额外的标签，上一层的元素也会获取鼠标事件。所以，如果这里能用 <code>:before</code>，<code>:after</code> 伪类是最理想的，可惜目前只有 Firefox 支持伪类变化。Eliott Sprehn 正在努力让 webkit 也支持伪类变化，这一功能很快也会在 Safari Chrome 上实现。</p>
<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>过渡某些属性，比如<code>left</code>、<code>margin</code>，浏览器会在每一帧重新计算样式。会引起不必要的重绘，成本相当昂贵，尤其是有很多元素的时候。在移动设置上，这个后果更加明显。</p>
<p>解决方法就是交给GPU来处理，用CSS的<code>transform</code>就可以触发。简单地说，就是将元素转化为图片再执行过渡效果，避免任何样式的重计算，这就大大提高了性能。强制浏览器开启硬件加速最简单的方法就是用<code>transform: translate3d(0,0,0)</code>。</p>
<p>不过，这不是解决性能问题的完美方法，它本身也有问题。在必要的时候，才开启硬件加速，不要盲目用到每一个元素上。<br>举个例子，硬件加速会引起微妙的字体问题，比如<code>font</code>会损失<code>weight</code>。原因就是硬件加速过程中不会对字体启用抗锯齿特效，避免这个问题只能禁用 <code>font-smoothing: antialiased;</code>。</p>
<p>另外，不同的浏览器使用不同的硬件加速库，这可能引起跨浏览器问题。比如，Chrome和Safari都基于WebKit，不过Chrome使用Skia来处理图形渲染，Safari使用CoreGraphics。区别是细微，但却是实实在在存在的。</p>
<p>使用Chrome自带的开发者工具，展示了当前页面所有的重绘。在<code>about:flags</code>中启用Composited Render Layer Borders，就可以看到由GPU操纵的层。减少绘画的关键就是批处理更新DOM，而且尽可能交由GPU处理。</p>
<p>如果硬件加速在不同浏览器中有显示问题，比如闪烁或者颤抖，那就放弃使用<code>transform3d()</code>属性。</p>
<h2 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h2><p>为了充分利用GPU渲染能力，使用CSS的<code>transform</code>而不是类似<code>width</code>的属性来避免重新计算。假如要变化元素的width，你将会怎么做？答案是使用clipping（术语，only drawing things that will be visible to the viewer）。</p>
<p>下面的例子，搜索框会有两个过渡状态，</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-21/87876292-file_1490026519380_1f4c.png" alt=""></p>
<p>搜索框拉宽，使用<code>translate3d</code>属性使元素在X轴上拉长，而不是<code>width</code>。</p>
<pre><code class="css">.clipped {
  overflow: hidden;
  position: relative;
}

.clipped .clip {
  right: 0px;
  width: 45px;
  height: 45px;
  background: url(/images/clip.png) no-repeat
}

input:focus {
  -webkit-transform: translate3d(-50px, 0, 0);
}
</code></pre>
<p>这样每一帧都不会重新计算元素的宽度，过渡将更加平稳丝滑，性能更好。</p>
<h2 id="动画函数"><a href="#动画函数" class="headerlink" title="动画函数"></a>动画函数</h2><p>到目前为止，我们已经使用了一些浏览器预置的动画函数：<code>lienar</code>，<code>ease</code>，<code>ease-in</code>，<code>ease-out</code>，<code>ease-in-out</code>。更复杂的话就是使用cubic-bezier曲线自定义动画函数。例如</p>
<pre><code class="css">transition: -webkit-transform 1s cubic-bezier(0.17,0.67,0.69,1.33);
</code></pre>
<p>有两个现成工具，可以帮你使用cubic-bezier曲线自定义动画函数：<a href="http://easings.net/" target="_blank" rel="external">Pre-defined Curves</a>和<a href="http://cubic-bezier.com/" target="_blank" rel="external">Graphing Tool</a>。</p>
<h2 id="程序化过渡效果"><a href="#程序化过渡效果" class="headerlink" title="程序化过渡效果"></a>程序化过渡效果</h2><p>写CSS transition非常好，但有时候需要更好的控制，特别是链式过渡。我们不仅要通过JavaScript来调用，还要定义它们。</p>
<p>CSS transition中有一个神奇的all属性，保证了任何改变的属性都可以过渡（前提这个属性是可过渡的）。</p>
<pre><code class="javascript">var defaults = {
  duration: 400,
  easing: &#39;&#39;
};

$.fn.transition = function (properties, options) {
  options = $.extend({}, defaults, options);
  properties[&#39;webkitTransition&#39;] = &#39;all &#39; + options.duration + &#39;ms &#39; + options.easing;
  $(this).css(properties);
};
</code></pre>
<p>然后用 jQuery 函数 $.fn.transition 调用变化样式。</p>
<pre><code class="javascript">$(&#39;.element&#39;).transition({background: &#39;red&#39;});
</code></pre>
<h2 id="transiton回调"><a href="#transiton回调" class="headerlink" title="transiton回调"></a>transiton回调</h2><p>下一步就是使用transition回调。在基于WebKit的浏览器中，可以监听<code>webkitTransitionEnd</code>事件。其他浏览器，只要改下事件名称前缀也是可以的。</p>
<pre><code class="javascript">var callback = function () {
    // ...
}

$(this).one(&#39;webkitTransitionEnd&#39;, callback)
$(this).css(properties);
</code></pre>
<p>注意有时候事件不会触发，通知都是因为属性没有改变或者绘画没有触发。为了保证执行这个回调，可以在<code>setTimeout</code>中手动触发事件。</p>
<pre><code class="javascript">$.fn.emulateTransitionEnd = function(duration) {
    var called = false, $el = this;
    $(this).one(&#39;webkitTransitionEnd&#39;, function() { called = true; });
    var callback = function() {
        if (!called) $($el).trigger(&#39;webkitTransitionEnd&#39;);
    };
    setTimeout(callback, duration);
};
</code></pre>
<p>现在我们就可以在设置元素CSS之前滴啊用<code>$.fn.emulateTransitionEnd()</code>，保证过渡以及回调都能触发。</p>
<pre><code class="javascript">$(this).one(&#39;webkitTransitionEnd&#39;, callback);
$(this).emulateTransitionEnd(options.duration + 50);
$(this).css(properties);
</code></pre>
<h2 id="链式过渡"><a href="#链式过渡" class="headerlink" title="链式过渡"></a>链式过渡</h2><p>因此现在我们可以通过代码应用过渡，结束后执行回调，这样过渡效果就可以以排队的方式一个一个执行。而jQuery库中存在同样的方法。</p>
<p>针对队列，jQuery提供了两个主要的函数方法，<code>$.fn.queue(callback)</code>和<code>$.fn.dequeue()</code>。前者是将回调添加到队列中，而后者是执行队列中的下一项。</p>
<p>换句话说，我们需要在队列回调中设置CSS的过渡，当过渡完成时确保调用了<code>$.fn.dequeue</code>。</p>
<pre><code class="javascript">var $el = $(this);
$el.queue(function(){
    $el.one(&#39;webkitTransitionEnd&#39;, function(){
        $el.dequeue();
    });
    $el.css(properties);
});
</code></pre>
<p>这个例子很简单，让我们用jQuery的<code>delay()</code>函数来构建复杂的链式动画。</p>
<pre><code class="javascript">$(&#39;.element&#39;).transition({left: &#39;20px&#39;})
             .delay(200)
             .transition({background: &#39;red&#39;});
</code></pre>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>一般过渡时，是有两组CSS属性。从起始属性过渡到最终属性。</p>
<pre><code class="javascript">$(&#39;.element&#39;).css({left: &#39;10px&#39;})
             .transition({left: &#39;20px&#39;});
</code></pre>
<p>然后，你会发现当应用两组CSS属性，一组紧挨着一组，浏览器会尝试优化这些属性的变化，忽略初始的属性，阻止过渡变化。在后台，浏览器在重绘前批处理样式的变化，这样会加快渲染速度，但有时也有不利的影响。</p>
<p>解决办法是利用DOM元素的<code>offsetHeight</code>属性让浏览器在两套样式之间强制重绘。</p>
<pre><code class="javascript">$.fn.redraw = function(){
    $(this).each(function(){
        var redraw = this.offsetHeight;
    });
};
</code></pre>
<p>这个方法在大多数浏览器下都能吃工作正常，但在Android下就不行，可以使用timeout或者激活一个class。</p>
<pre><code class="javascript">$(&#39;.element&#39;).css({left: &#39;10px&#39;})
             .redraw()
             .transition({left: &#39;20px&#39;});
</code></pre>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>草案一直在积极的制定，而接下来的规格说明看起来真的很有希望。草种中包含新的Javascript API应对现在的局限性，给开发者更灵活的空间。</p>
<p>事实上，你可以在github上找到这些新API的(垫片)[<a href="https://github.com/web-animations/web-animations-js]。" target="_blank" rel="external">https://github.com/web-animations/web-animations-js]。</a></p>
<pre><code class="javascript">var anim = new Animation(elem, { left: &#39;100px&#39; }, 3);
anim.play();
</code></pre>
<p>使用这个API可以同步动画，提供个性化的动画函数，以及完成以后的回调。这都是令人相当兴奋的。</p>
<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2><p>目前为止，希望你已经深入的了解了CSS的<code>transition</code>属性，以及如何组合简单的API制作丰富的动画效果。</p>
<p>文中大多数js 例子来源于GFX，一个jQuery的CSS transtion库。里面内置了很多效果，例如滑动、爆炸、3D翻转。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS3中的transform]]></title>
      <url>http://www.sevenhdu.space/2015/06/15/CSS3-transform/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>transform可以对元素应用2D或3D变换，包括移动（translate）、缩放（scale）、倾斜（skew）、旋转（rotate）。通过transform可以实现很多动画效果。</p>
<a id="more"></a>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><table>
<thead>
<tr>
<th style="text-align:left">例子</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">translate(50px, 100px)</td>
<td style="text-align:right">元素向右平移50px,向下平移100px</td>
</tr>
<tr>
<td style="text-align:left">scale(2, 3)</td>
<td style="text-align:right">元素宽度扩大2倍，高度扩大3倍</td>
</tr>
<tr>
<td style="text-align:left">skew(20deg)</td>
<td style="text-align:right">元素在X轴倾斜20°</td>
</tr>
<tr>
<td style="text-align:left">rotate(60deg)</td>
<td style="text-align:right">元素顺时针旋转60°</td>
</tr>
</tbody>
</table>
<p>可以同一个元素使用多个不同类型的变换，只要变换之间以空格隔开</p>
<pre><code class="css">transform: translate(50px, 100px) scale(2, 3) rotate(60deg);
</code></pre>
<p>还有高级用法矩阵matrix，它可以将多个变换整合到一个变换函数中。<br>比如<br><code>rotate(45deg) translate(24px,25px)</code><br>对应<br><code>matrix(0.707107, 0.707107, -0.707107, 0.707107, -0.707107, 34.6482)</code><br>有这样一个转换的网站，可以自己试试看。<a href="http://meyerweb.com/eric/tools/matrix/" target="_blank" rel="external">传送门</a></p>
<p>想深入理解可以看看这篇文章<a href="http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/" target="_blank" rel="external">理解CSS3 transform中的Matrix(矩阵)</a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>直接上例子，为了让变换不那么生硬，加了过渡属性transition。</p>
<iframe height="265" scrolling="no" title="CSS3 transform" src="//codepen.io/SevenHDU/embed/YZxROr/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/SevenHDU/pen/YZxROr/" target="_blank" rel="external">CSS3 transform</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h2 id="transform-origin的玄机"><a href="#transform-origin的玄机" class="headerlink" title="transform-origin的玄机"></a>transform-origin的玄机</h2><p>transfrom属性和transform-origin是息息相关的。transform是以tranform-origin的值作为原点进行变换的，默认是中心点。<br>看下面的例子。</p>
<iframe height="300" scrolling="no" title="Transform-origin" src="//codepen.io/SevenHDU/embed/wJrggy/?height=300&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/wJrggy/" target="_blank" rel="external">Transform-origin</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h2 id="在桌面端和移动端用CSS开启硬件加速"><a href="#在桌面端和移动端用CSS开启硬件加速" class="headerlink" title="在桌面端和移动端用CSS开启硬件加速"></a>在桌面端和移动端用CSS开启硬件加速</h2><p>浏览器检测到元素应用某些CSS属性时，会开启硬件加速。其中一个就是3D变换。<br>例如</p>
<pre><code class="css">.ele {
   -webkit-transform: translate3d(250px,250px,250px)
   rotate3d(250px,250px,250px,-120deg)
   scale3d(0.5, 0.5, 0.5);
}
</code></pre>
<p>可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。</p>
<pre><code class="css">.ele {
   -webkit-transform: translateZ(0)
}
</code></pre>
<p>硬件加速在移动端尤其有用。<br>通过开启GPU硬件加速虽然可以提升动画渲染性能或解决一些棘手问题，但使用仍需谨慎，使用前一定要进行严谨的测试，否则它反而会大量占用浏览网页用户的系统资源，尤其是在移动端，肆无忌惮的开启GPU硬件加速会导致大量消耗设备电量，降低电池寿命等问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transforms/Using_CSS_transforms" target="_blank" rel="external">Using CSS transforms</a></li>
<li><a href="https://css-tricks.com/almanac/properties/t/transform/" target="_blank" rel="external">transform</a></li>
<li><a href="http://www.cnblogs.com/PeunZhang/p/3510083.html" target="_blank" rel="external">用CSS开启硬件加速来提高网站性能</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS中的伪类和伪元素]]></title>
      <url>http://www.sevenhdu.space/2015/03/05/css-pseudo-class-and-pseudo-elments/</url>
      <content type="html"><![CDATA[<p>先看<code>W3C</code>的定义<br>. <strong>CSS伪类</strong> 用于向某些选择器添加特殊的效果<br>. <strong>CSS伪元素</strong> 用于向某些选择器设置特殊效果</p>
<p>光看定义，其实还是云里雾里的，所以还是要深入研究下才能搞明白他们的作用。</p>
<a id="more"></a>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪类与类相似，但又没有类附加标签上。伪类分为UI伪类和结构化伪类。</p>
<h3 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h3><ul>
<li>:link(将样式添加到未被访问的链接上)</li>
<li>:visted(将样式已添加到访问的链接上)</li>
<li>:hover(将样式添加到鼠标悬浮的元素上)</li>
<li>:active(将样式添加到被激活的元素上)</li>
<li>:focus(将样式添加到被选中的元素上)</li>
</ul>
<h3 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h3><ul>
<li>:first-child(将样式添加到第一个子元素上)</li>
<li>:last-child(将样式添加到最后一个子元素上)</li>
</ul>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素是在文档中若有实无的元素。<br>主要有以下几种</p>
<ul>
<li>:first-letter(将样式添加到第一个字母)</li>
<li>:first-line(将样式添加到第一行)</li>
<li>:before(在某些元素前面插入某些内容)</li>
<li>:after(在某些元素后面插入某些内容)</li>
</ul>
<p>看到:after，大家脑子里应该都能想到那个经典的清除浮动的CSS的吧。没错，就是这个。</p>
<pre><code class="css">.clearfix:after {
    content:&quot;.&quot;;
    display:block;
    height:0;
    visibility:hidden;
    clear:both;
}
</code></pre>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p><strong>伪类的实现就好比给这个标签添加了一个虚拟的类。</strong><br>举个栗子</p>
<pre><code class="html">a:hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>若不用伪类，实现同样的效果，需要这么做</p>
<pre><code class="html">.hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>这么一对比，”伪类“的概念是不是清晰了很多。</p>
<p><strong>而伪元素则好比添加了一个新的标签。</strong></p>
<pre><code class="html">p:first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;Hello,World&lt;/p&gt;
</code></pre>
<p>若不用伪元素，实现同样的效果，需要添加一个额外的标签</p>
<pre><code class="html">.first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;&lt;span class=&quot;first-letter&quot;&gt;H&lt;/span&gt;ello,World&lt;/p&gt;
</code></pre>
<p>因此总结下区分的方法：<strong>现实相同效果是需要添加一个类还是一个元素标签。</strong></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>CSS3为了区别伪类和伪元素，明确使用单冒号来表示伪类，双冒号来表示伪元素。但为兼容性考虑，目前基本还是使用单冒号来表示。</li>
<li>搜索引擎不会搜索伪元素的信息。因此，不要通过伪元素添加你想让搜索引擎索引的重要内容</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解DOM事件流]]></title>
      <url>http://www.sevenhdu.space/2014/10/16/dom-event-flow/</url>
      <content type="html"><![CDATA[<p>当浏览器发展到第四代时（IE4和Netscape Communicator 4）,浏览器团队遇到一个很有意思的问题：页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面。<br>事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流。</p>
<a id="more"></a>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。看下面的例子</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>点击按钮，那么这个click事件会按照以下顺序传播：<br>1.input<br>2.div<br>3.body<br>4.html<br>5.document</p>
<p>虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获。</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。以前面的例子，则会按下图顺序触发事件。</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-15/54841141-file_1487127495480_10fd7.png" alt="事件流"></p>
<p>在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到div后就停止了。下一个阶段是处于目标阶段，于是事件在input上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。</p>
<p>多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上操作事件。  看如下例子。</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;wrap&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var wrap = document.getElementById(&quot;wrap&quot;);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;冒泡&quot;);
            }, false);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;捕获&quot;);
            }, true)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这个Demo的结果，应该很清楚了吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DB2日期分组计算数据值]]></title>
      <url>http://www.sevenhdu.space/2014/08/18/DB2-sum-groupby/</url>
      <content type="html"><![CDATA[<p>最近参与的项目进行了一次优化技改，对其中SQL参数化公用方法进行了改造。又因项目组人员调整，接手其他模块。</p>
<p>在其他模块测试过程发现，一个针对日期分组计算的SQL报错，报SQL语句超长的异常。</p>
<a id="more"></a>
<p>举个栗子，功能要求如下：</p>
<p>表TABLE_TEST中</p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:center">AMOUNT</th>
<th style="text-align:right">CREATE_DATE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-01</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-09</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-11</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-21</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-24</td>
</tr>
</tbody>
</table>
<p>需求是从表中按CREAT_DATE每10天作为一个分组，统计总金额</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>之前的SQL是这样子的</p>
<pre><code class="SQL">SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-01&#39; AND &#39;2014-01-10&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-11&#39; AND &#39;2014-01-20&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-21&#39; AND &#39;2014-01-30&#39;
</code></pre>
<p>这个SQL主要有两方面问题，一方面程序逻辑发杂，需要算计每10天时间间隔的起始日期，还有一个方面是SQL语句冗长，如果日期跨度大的话，SQL语句就回相当长，直接导致程序抛异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>改进的SQL</p>
<pre><code class="SQL">SELECT SUM(AMOUNT) AS TOTALAMOUNT , (days(CREATE_DATE)-days(&#39;2014-01-01&#39;))/10 AS TIMESAPN
FROM TABLE_TEST GROUP BY TIMESAPN
</code></pre>
<p>关键部分在于  <strong>(days(CREATE_DATE)-days(‘2014-01-01’))/10 AS TIMESAPN</strong></p>
<p>TIMESAPN为0则表示该记录在第一个10天周期内，为1表示在第二个10天周期内，以此类推，最后以此字段作为分组条件，就可以达到上面SQL同样的效果。</p>
]]></content>
    </entry>
    
  
  
</search>
