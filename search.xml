<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[阅读Redux源码]]></title>
      <url>http://www.sevenhdu.space/2017/05/20/read-redux-source-code/</url>
      <content type="html"><![CDATA[<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-7-20/45502578.jpg" alt="Redux"></p>
<p>前段时间看了下Redux的源码，觉得很有必要写个Blog记下来，算是一个加深印象，巩固知识的过程。</p>
<a id="more"></a>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><pre><code class="javascript">| ── util
|     └── warning.js
| ── applyMiddleware.js                     
| ── bindActionCreators.js
| ── combineReducers.js  
| ── compose.js
| ── createStore.js
| ── index.js
</code></pre>
<p>index.js是入口文件，主要做的作用就是export其他模块。</p>
<h2 id="compose-js"><a href="#compose-js" class="headerlink" title="compose.js"></a>compose.js</h2><p>工具方法,很受函数式编程思想的影响。</p>
<pre><code class="javascript">/**
 * 将多个函数合并成一个函数，嵌套执行
 * 执行顺序从右到左，前一个函数的执行结果作为下一个函数的参数
 *
 *
 * @param {...Function} 待组合的函数.
 * @returns {Function} 一个从右到左执行的一个函数
 * 举个例子, compose(f, g, h) 最后就是 (...args) =&gt; f(g(h(...args))).
 */

export default function compose(...funcs) {
  if (funcs.length === 0) {
    return arg =&gt; arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))
}
</code></pre>
<p>最核心的方法就是reduce，将多个函数包括起来，依次执行。</p>
<p>reduce详细信息可以查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/reduce" target="_blank" rel="external">MDN</a></p>
<h2 id="bindActionCreators-js"><a href="#bindActionCreators-js" class="headerlink" title="bindActionCreators.js"></a>bindActionCreators.js</h2><pre><code class="javascript">

/**
 * 用 dispatch 封装 actionCreators。
 * 封装好可以直接调用 boundActionCreator()，无需 dispatch。
 * dispatch(actionCreator()) -&gt; boundActionCreator()
 *
 * @param {Function|Object} actionCreators 即可以是Object也可以直接是function。Object的话可以通过 ES6语法中 * as ActionCreator
 * @param {Function} dispatch 就是Store的dispatch方法
 * @returns {Function|Object}
 */
export default function bindActionCreators(actionCreators, dispatch) {
  //如果actionCreators是函数，则直接挑用
  if (typeof actionCreators === &#39;function&#39;) {
    return bindActionCreator(actionCreators, dispatch)
  }

  //如果acrionCreatirs不是对应或者是null，则异常
  if (typeof actionCreators !== &#39;object&#39; || actionCreators === null) {
    throw new Error(
      `...`
    )
  }

  //actionCreators中的key所组成的数组
  const keys = Object.keys(actionCreators)
  const boundActionCreators = {}
  for (let i = 0; i &lt; keys.length; i++) {
    const key = keys[i]
    const actionCreator = actionCreators[key]
    if (typeof actionCreator === &#39;function&#39;) {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)
    }
  }
  return boundActionCreators
}

//返回包裹了dispatch的函数
function bindActionCreator(actionCreator, dispatch) {
  return (...args) =&gt; dispatch(actionCreator(...args))
}
</code></pre>
<p>bindActionCreators将actionCreators转换成了拥有同名key的对象，而且可以直接调用，这样actionCreator传给组件的时候，可以让组件察觉不到Redux的存在。</p>
<h2 id="combineReducers-js"><a href="#combineReducers-js" class="headerlink" title="combineReducers.js"></a>combineReducers.js</h2><pre><code class="javascript">/**
 * 将包含了多个不同的reducer函数的对象，转换成一个reducer函数
 *
 * @param {Object} reducers 包含了多个不同的reducer函数的对象
 *
 * @returns {Function} 一个可以调用每个reducer的总reducer函数
 */
export default function combineReducers(reducers) {
  const reducerKeys = Object.keys(reducers)
  const finalReducers = {}
  //遍历一遍，保证finalReducers中的属性都是函数
  for (let i = 0; i &lt; reducerKeys.length; i++) {
    const key = reducerKeys[i]

    if (process.env.NODE_ENV !== &#39;production&#39;) {
      if (typeof reducers[key] === &#39;undefined&#39;) {
        warning(`No reducer provided for key &quot;${key}&quot;`)
      }
    }

    if (typeof reducers[key] === &#39;function&#39;) {
      finalReducers[key] = reducers[key]
    }
  }
  const finalReducerKeys = Object.keys(finalReducers)

  let unexpectedKeyCache
  if (process.env.NODE_ENV !== &#39;production&#39;) {
    unexpectedKeyCache = {}
  }

  let shapeAssertionError
  try {
    assertReducerShape(finalReducers)
  } catch (e) {
    shapeAssertionError = e
  }

  return function combination(state = {}, action) {
    if (shapeAssertionError) {
      throw shapeAssertionError
    }

    if (process.env.NODE_ENV !== &#39;production&#39;) {
      const warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache)
      if (warningMessage) {
        warning(warningMessage)
      }
    }

    let hasChanged = false
    const nextState = {}
    // 开始循环各个 reducer
    for (let i = 0; i &lt; finalReducerKeys.length; i++) {
      //获取key,方便后面获取对应的state
      const key = finalReducerKeys[i]
      const reducer = finalReducers[key]
      const previousStateForKey = state[key]
      const nextStateForKey = reducer(previousStateForKey, action)
      if (typeof nextStateForKey === &#39;undefined&#39;) {
        const errorMessage = getUndefinedStateErrorMessage(key, action)
        throw new Error(errorMessage)
      }
      nextState[key] = nextStateForKey
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey
    }
    return hasChanged ? nextState : state
  }
}
</code></pre>
<p>combineReducers 辅助函数的作用是，把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore</p>
<h2 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h2><pre><code class="javascript">/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares 将要应用的中间件链
 * @returns {Function} 一个应用了中间件链的 store 增强剂.
 */
export default function applyMiddleware(...middlewares) {
  return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; {
    //创建store
    const store = createStore(reducer, preloadedState, enhancer)
    let dispatch = store.dispatch
    let chain = []

    const middlewareAPI = {
      getState: store.getState,
      dispatch: (action) =&gt; dispatch(action)
    }
    //每个中间件都注入了middlewareAPI参数，调用一次
    chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))
    //调用compose函数,以后chain中的中间件函数从右到左依次执行，达到增强dispatch的效果
    dispatch = compose(...chain)(store.dispatch)

    return {
      ...store,
      dispatch
    }
  }
}
</code></pre>
<p>使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息。<br>Middleware 最常见的使用场景是无需引用大量代码或依赖第三方库实现异步 actions。这种方式可以让你像 dispatch 一般的 actions 那样 dispatch 异步 actions。</p>
<h2 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h2><pre><code class="javascript">/**
 * 它创建一个 Redux store 来以存放应用中所有的 state
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] 初始状态
 *
 * @param {Function} [enhancer] store 增强剂. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */
export default function createStore(reducer, preloadedState, enhancer) {
  if (typeof preloadedState === &#39;function&#39; &amp;&amp; typeof enhancer === &#39;undefined&#39;) {
    enhancer = preloadedState
    preloadedState = undefined
  }

  if (typeof enhancer !== &#39;undefined&#39;) {
    if (typeof enhancer !== &#39;function&#39;) {
      throw new Error(&#39;Expected the enhancer to be a function.&#39;)
    }

    return enhancer(createStore)(reducer, preloadedState)
  }

  if (typeof reducer !== &#39;function&#39;) {
    throw new Error(&#39;Expected the reducer to be a function.&#39;)
  }

  let currentReducer = reducer
  let currentState = preloadedState
  let currentListeners = []
  let nextListeners = currentListeners
  let isDispatching = false

  //保证nextListeners可变
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice()
    }
  }


  //获取state, 这是一个闭包，这个参数会持久存在
  function getState() {
    return currentState
  }

  /**
   * 添加监听函数，dispatch的时候会调用监听函数
   *
   * @param {Function} 监听函数
   * @returns {Function} 返回一个解绑的函数.
   */
  function subscribe(listener) {
    if (typeof listener !== &#39;function&#39;) {
      throw new Error(&#39;Expected listener to be a function.&#39;)
    }

    let isSubscribed = true

    ensureCanMutateNextListeners()
    nextListeners.push(listener)

    return function unsubscribe() {
      if (!isSubscribed) {
        return
      }

      isSubscribed = false

      ensureCanMutateNextListeners()
      const index = nextListeners.indexOf(listener)
      nextListeners.splice(index, 1)
    }
  }

  /**
   * Dispatches an action. 这是唯一改变state的途径.
   *
   * @param {Object} action  一个纯对象，必须包含一个type属性
   *
   * @returns {Object}
   *
   */
  function dispatch(action) {
    //不是纯对象，则报异常
    if (!isPlainObject(action)) {
      throw new Error(
        &#39;Actions must be plain objects. &#39; +
        &#39;Use custom middleware for async actions.&#39;
      )
    }

    //判断type属性
    if (typeof action.type === &#39;undefined&#39;) {
      throw new Error(
        &#39;Actions may not have an undefined &quot;type&quot; property. &#39; +
        &#39;Have you misspelled a constant?&#39;
      )
    }

    // 如果正在 dispatch 则抛出错误
    if (isDispatching) {
      throw new Error(&#39;Reducers may not dispatch actions.&#39;)
    }

    try {
      isDispatching = true
      //执行当前的reducer
      currentState = currentReducer(currentState, action)
    } finally {
      isDispatching = false
    }

    //执行监听函数
    const listeners = currentListeners = nextListeners
    for (let i = 0; i &lt; listeners.length; i++) {
      const listener = listeners[i]
      listener()
    }

    return action
  }

  /**
   * 替换reducer
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== &#39;function&#39;) {
      throw new Error(&#39;Expected the nextReducer to be a function.&#39;)
    }

    currentReducer = nextReducer
    dispatch({ type: ActionTypes.INIT })
  }

  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */
  function observable() {
    const outerSubscribe = subscribe
    return {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe(observer) {
        if (typeof observer !== &#39;object&#39;) {
          throw new TypeError(&#39;Expected the observer to be an object.&#39;)
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState())
          }
        }

        observeState()
        const unsubscribe = outerSubscribe(observeState)
        return { unsubscribe }
      },

      [$$observable]() {
        return this
      }
    }
  }


  // store创建完以后，dispatch一个“INIT”的action,可以让reducer return初始化的state
  dispatch({ type: ActionTypes.INIT })

  return {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable
  }
}
</code></pre>
<p>创建一个 Redux store 来以存放应用中所有的 state。应用中应有且仅有一个 store。<br>返回的对应包含那么几个方法：</p>
<ul>
<li>dispatch 改变Store中state的唯一方法</li>
<li>subscribe 添加监听事件，dispatch以后，会执行这个监听事件</li>
<li>getState  返回Store的state树</li>
<li>replaceReducer 替换reducer</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在移动端触发手机拨打电话]]></title>
      <url>http://www.sevenhdu.space/2017/03/15/make-call-in-mobile/</url>
      <content type="html"><![CDATA[<p>在移动端的项目中，经常会有这样的需求，点击按钮触发手机拨打电话。<br><a id="more"></a><br>这个需求其实很简单，按照下面的写法其实就可以实现。</p>
<pre><code class="html">&lt;a href=&quot;tel:10086&quot;&gt;拨打电话&lt;/a&gt;
</code></pre>
<p>而最近遇到的需求是电话号码动态变化的，因此想着能不能通过js来动态触发这个动作。搜了一下果然是有方法的。</p>
<pre><code class="javascript">function makeCall(telNo){
    window.location.href = &quot;tel:&quot; + telNo;
}
</code></pre>
<p>亲测，在IOS中微信、Safari、UC以及Android中的微信、UC均可触发拨打电话效果。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在Webpack中动态引用资源]]></title>
      <url>http://www.sevenhdu.space/2017/02/22/dynamic-requires-in-webpack/</url>
      <content type="html"><![CDATA[<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-22/509920-file_1490187075588_10c58.jpg" alt="Webpack"></p>
<a id="more"></a>
<p>最近项目中遇到一个问题，就是想把img目录下所有的图片资源动态加载进来。项目使用webpack构建的。</p>
<p>笨办法就是这样。</p>
<pre><code class="javascript">import img1 from &quot;./img/img1.png&quot;;
import img2 from &quot;./img/img2.png&quot;;
import img3 from &quot;./img/img3.png&quot;;
</code></pre>
<p>这办法明显是不可取，不利于维护。之前使用FIS的时候，也遇到过类似问题，使用<code>__CDNPATH</code>这个变量来解决的。Webpack也有办法的。</p>
<pre><code class="javascript">
let banner = [{
    img : &quot;./img1.jpg&quot;,
    url : &quot;http://example.com&quot;
},{
    img : &quot;./img2.jpg&quot;,
    url : &quot;http://example.com&quot;
},{
    img : &quot;./img3.jpg&quot;,
    url : &quot;http://example.com&quot;
}];

let req = require.context(&quot;../img&quot;, true, /^\.\/.*\.jpg/);
//读取banner
const images  = banner.map((item)=&gt;{
    return {
        img  : req(item.image),
        url  : item.url
    }
});
</code></pre>
<p><code>require.context</code>可以创建自己的上下文。允许传三个参数</p>
<ul>
<li>匹配的目录</li>
<li>是否包含子目录的布尔值</li>
<li>匹配具体文件的正则</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://webpack.github.io/docs/context.html" target="_blank" rel="external">Webpack CONTEXT</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决在IOS下无法自动播放音频的问题]]></title>
      <url>http://www.sevenhdu.space/2016/09/21/autoplay-auido-in-ios/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道在IOS下H5页面是无法自动播放音频，必须通过用户交互比如点击等才能播放音频。IOS是为了防止偷跑流量才这么做的。但是很多H5项目中播放背景音频是一个很习以为常的需求。那该怎么办呢？答案就在微信的WeixinJSBridgeReady事件。</p>
<a id="more"></a>
<blockquote>
<p>JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action.</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>WeixinJSBridgeReady是微信自带的事件，只要监听这个事件，在执行函数里播放音频，就可以实现在微信中自动播放音频的功能。（毕竟微信渠道的量大，一定要保证微信是可以正常播放音频）</p>
<pre><code class="html">&lt;audio src=&quot;bgAudio.mp3&quot; id=&quot;bgAudio&quot; preload loop=&quot;loop&quot;&gt;&lt;/audio&gt;
</code></pre>
<pre><code class="javascript">function playBgAudio(){
    var bgAudio = document.getElementById(&quot;bgAudio&quot;);
    bgAudio.play();

    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function(){
        bgAudio.play();
    }, false);
}
</code></pre>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>很多同学发现用了上面的代码也没什么卵用，因为这里面还有个坑。上面的代码必须放在WeixinJSBridgeReady执行以前，如果WeixinJSBridgeReady事件都执行，再监听就没什么用了。<strong><em>所以监听的js代码一定要放在head前面，以确保最先执行</em></strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[fixed定位元素在设置了transform属性父元素下失效]]></title>
      <url>http://www.sevenhdu.space/2016/09/17/position-fixed-not-work-in-transform/</url>
      <content type="html"><![CDATA[<p>最近项目开发中遇到了一个奇怪的现象，<code>position:fixed</code>设置元素竟然不相对浏览器定位。最后发现原来是transform捣的鬼。<br>当fixed元素作为transform元素的资源时，<code>position:fixed</code>固定效果将失效，降级成类似<code>position:absolute</code>的表现。</p>
<a id="more"></a>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><iframe height="265" scrolling="no" title="jBaKqW" src="//codepen.io/SevenHDU/embed/jBaKqW/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/SevenHDU/pen/jBaKqW/" target="_blank" rel="external">jBaKqW</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>看完上面的例子，应该就清晰很多了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/" target="_blank" rel="external">CSS3 transform对普通元素的N多渲染影响</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何在 Git 里撤销(几乎)任何操作]]></title>
      <url>http://www.sevenhdu.space/2016/06/28/git-undo/</url>
      <content type="html"><![CDATA[<blockquote>
<p>原文地址：<a href="http://blog.jobbole.com/87700/" target="_blank" rel="external">http://blog.jobbole.com/87700/</a></p>
</blockquote>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-6-28/98243103.jpg" alt=""></p>
<a id="more"></a>
<p>任何版本控制系统的一个最有的用特性就是“撤销 (undo)”你的错误操作的能力。在 Git 里，“撤销” 蕴含了不少略有差别的功能。</p>
<p>当你进行一次新的提交的时候，Git 会保存你代码库在那个特定时间点的快照；之后，你可以利用 Git 返回到你的项目的一个早期版本。</p>
<p>在本篇博文里，我会讲解某些你需要“撤销”已做出的修改的常见场景，以及利用 Git 进行这些操作的最佳方法。</p>
<h2 id="撤销一个“已公开”的改变"><a href="#撤销一个“已公开”的改变" class="headerlink" title="撤销一个“已公开”的改变"></a>撤销一个“已公开”的改变</h2><p><strong>场景</strong>: 你已经执行了 git push, 把你的修改发送到了 GitHub，现在你意识到这些 commit 的其中一个是有问题的，你需要撤销那一个 commit。</p>
<p><strong>方法</strong>: <code>git revert &lt;SHA&gt;</code></p>
<p><strong>原理</strong>: git revert 会产生一个新的 commit，它和指定 SHA 对应的 commit 是相反的（或者说是反转的）。如果原先的 commit 是“物质”，新的 commit 就是“反物质” — 任何从原先的 commit 里删除的内容会在新的 commit 里被加回去，任何在原先的 commit 里加入的内容会在新的 commit  里被删除。</p>
<p>这是 Git 最安全、最基本的撤销场景，因为它并不会改变历史 — 所以你现在可以  git push 新的“反转” commit 来抵消你错误提交的 commit。</p>
<h2 id="修正最后一个-commit-消息"><a href="#修正最后一个-commit-消息" class="headerlink" title="修正最后一个 commit 消息"></a>修正最后一个 commit 消息</h2><p><strong>场景</strong>: 你在最后一条 commit 消息里有个笔误，已经执行了 git commit -m “Fxies bug #42”，但在 git push 之前你意识到消息应该是 “Fixes bug #42″。</p>
<p><strong>方法</strong>: <code>git commit --amend 或 git commit --amend -m &quot;Fixes bug #42&quot;</code></p>
<p><strong>原理</strong>: git commit –amend 会用一个新的 commit 更新并替换最近的 commit ，这个新的 commit 会把任何修改内容和上一个 commit 的内容结合起来。如果当前没有提出任何修改，这个操作就只会把上次的 commit 消息重写一遍。</p>
<h2 id="撤销“本地的”修改"><a href="#撤销“本地的”修改" class="headerlink" title="撤销“本地的”修改"></a>撤销“本地的”修改</h2><p><strong>场景</strong>: 一只猫从键盘上走过，无意中保存了修改，然后破坏了编辑器。不过，你还没有 commit 这些修改。你想要恢复被修改文件里的所有内容 — 就像上次 commit 的时候一模一样。</p>
<p><strong>方法</strong>: <code>git checkout -- &lt;bad filename&gt;</code></p>
<p><strong>原理</strong>: git checkout 会把工作目录里的文件修改到 Git 之前记录的某个状态。你可以提供一个你想返回的分支名或特定 SHA ，或者在缺省情况下，Git 会认为你希望 checkout 的是 HEAD，当前 checkout 分支的最后一次 commit。</p>
<p><strong>记住</strong>：你用这种方法“撤销”的任何修改真的会完全消失。因为它们从来没有被提交过，所以之后 Git 也无法帮助我们恢复它们。你要确保自己了解你在这个操作里扔掉的东西是什么！（也许可以先利用 git diff 确认一下）</p>
<h2 id="重置“本地的”修改"><a href="#重置“本地的”修改" class="headerlink" title="重置“本地的”修改"></a>重置“本地的”修改</h2><p><strong>场景</strong>: 你在本地提交了一些东西（还没有 push），但是所有这些东西都很糟糕，你希望撤销前面的三次提交 — 就像它们从来没有发生过一样。</p>
<p><strong>方法</strong>: <code>git reset &lt;last good SHA&gt; 或 git reset --hard &lt;last good SHA&gt;</code></p>
<p><strong>原理</strong>: git reset 会把你的代码库历史返回到指定的 SHA 状态。 这样就像是这些提交从来没有发生过。缺省情况下， git reset 会保留工作目录。这样，提交是没有了，但是修改内容还在磁盘上。这是一种安全的选择，但通常我们会希望一步就“撤销”提交以及修改内容 — 这就是 –hard 选项的功能。</p>
<p>##在撤销“本地修改”之后再恢复</p>
<p><strong>场景</strong>: 你提交了几个 commit，然后用 git reset –hard 撤销了这些修改（见上一段），接着你又意识到：你希望还原这些修改！</p>
<p><strong>方法</strong>: git reflog 和 git reset 或 git checkout</p>
<p><strong>原理</strong>: git reflog 对于恢复项目历史是一个超棒的资源。你可以恢复几乎 任何东西 — 任何你 commit 过的东西 — 只要通过 reflog。</p>
<p>你可能已经熟悉了 git log 命令，它会显示 commit 的列表。 git reflog 也是类似的，不过它显示的是一个 HEAD 发生改变的时间列表.</p>
<p>一些注意事项</p>
<ul>
<li>它涉及的只是 HEAD 的改变。在你切换分支、用 git commit 进行提交、以及用 git reset 撤销 commit 时，HEAD 会改变，但当你用  git checkout – <bad filename=""> 撤销时（正如我们在前面讲到的情况），HEAD 并不会改变 — 如前所述，这些修改从来没有被提交过，因此 reflog 也无法帮助我们恢复它们。</bad></li>
<li>git reflog 不会永远保持。Git 会定期清理那些 “用不到的” 对象。不要指望几个月前的提交还一直躺在那里。</li>
<li>你的 reflog 就是你的，只是你的。你不能用 git reflog 来恢复另一个开发者没有 push 过的 commit。</li>
</ul>
<p>那么…你怎么利用 reflog 来“恢复”之前“撤销”的 commit 呢？它取决于你想做到的到底是什么：</p>
<ul>
<li>如果你希望准确地恢复项目的历史到某个时间点，用 <code>git reset --hard &lt;SHA&gt;</code></li>
<li>如果你希望重建工作目录里的一个或多个文件，让它们恢复到某个时间点的状态，用 <code>git checkout &lt;SHA&gt; -- &lt;filename&gt;</code></li>
<li>如果你希望把这些 commit 里的某一个重新提交到你的代码库里，用 <code>git cherry-pick &lt;SHA&gt;</code></li>
</ul>
<h2 id="利用分支的另一种做法"><a href="#利用分支的另一种做法" class="headerlink" title="利用分支的另一种做法"></a>利用分支的另一种做法</h2><p><strong>场景</strong>: 你进行了一些提交，然后意识到你开始 check out 的是 master 分支。你希望这些提交进到另一个特性（feature）分支里。</p>
<p><strong>方法</strong>: git branch feature, git reset –hard origin/master, and git checkout feature</p>
<p><strong>原理</strong>: 你可能习惯了用 git checkout -b <name> 创建新的分支 — 这是创建新分支并马上 check out 的流行捷径 — 但是你不希望马上切换分支。这里， git branch feature 创建一个叫做 feature 的新分支并指向你最近的 commit，但还是让你 check out 在 master 分支上。</name></p>
<p>下一步，在提交任何新的 commit 之前，用 git reset –hard 把 master 分支倒回 origin/master 。不过别担心，那些 commit 还在 feature 分支里。</p>
<p>最后，用 git checkout 切换到新的 feature 分支，并且让你最近所有的工作成果都完好无损。</p>
<h2 id="及时分支，省去繁琐"><a href="#及时分支，省去繁琐" class="headerlink" title="及时分支，省去繁琐"></a>及时分支，省去繁琐</h2><p><strong>场景</strong>: 你在 master 分支的基础上创建了 feature 分支，但 master 分支已经滞后于 origin/master 很多。现在 master 分支已经和 origin/master 同步，你希望在 feature 上的提交是从现在开始，而不是也从滞后很多的地方开始。</p>
<p><strong>方法</strong>: git checkout feature 和 git rebase master</p>
<p><strong>原理</strong>: 要达到这个效果，你本来可以通过 git reset (不加 –hard, 这样可以在磁盘上保留修改) 和 git checkout -b <new branch="" name=""> 然后再重新提交修改，不过这样做的话，你就会失去提交历史。我们有更好的办法。</new></p>
<p>git rebase master 会做如下的事情：</p>
<ul>
<li>首先它会找到你当前 check out 的分支和 master 分支的共同祖先。</li>
<li>然后它 reset 当前  check out 的分支到那个共同祖先，在一个临时保存区存放所有之前的提交。</li>
<li>然后它把当前 check out 的分支提到 master 的末尾部分，并从临时保存区重新把存放的 commit 提交到 master 分支的最后一个 commit 之后。</li>
</ul>
<h2 id="大量的撤销-恢复"><a href="#大量的撤销-恢复" class="headerlink" title="大量的撤销/恢复"></a>大量的撤销/恢复</h2><p><strong>场景</strong>: 你向某个方向开始实现一个特性，但是半路你意识到另一个方案更好。你已经进行了十几次提交，但你现在只需要其中的一部分。你希望其他不需要的提交统统消失。</p>
<p><strong>方法</strong>: <code>git rebase -i &lt;earlier SHA&gt;</code></p>
<p><strong>原理</strong>: -i 参数让 rebase 进入“交互模式”。它开始类似于前面讨论的 rebase，但在重新进行任何提交之前，它会暂停下来并允许你详细地修改每个提交。</p>
<p>rebase -i 会打开你的缺省文本编辑器，里面列出候选的提交。如下所示：</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-6-29/40773304.jpg" alt=""></p>
<p>前面两列是键：第一个是选定的命令，对应第二列里的 SHA 确定的 commit。缺省情况下， rebase -i  假定每个 commit 都要通过  pick 命令被运用。</p>
<p>要丢弃一个 commit，只要在编辑器里删除那一行就行了。如果你不再需要项目里的那几个错误的提交，你可以删除上例中的1、3、4行。</p>
<p>如果你需要保留 commit 的内容，而是对 commit 消息进行编辑，你可以使用 reword 命令。 把第一列里的 pick 替换为 reword (或者直接用 r)。有人会觉得在这里直接重写 commit 消息就行了，但是这样不管用 —rebase -i 会忽略 SHA 列前面的任何东西。它后面的文本只是用来帮助我们记住 0835fe2 是干啥的。当你完成 rebase -i 的操作之后，你会被提示输入需要编写的任何 commit 消息。</p>
<p>如果你需要把两个 commit 合并到一起，你可以使用 squash 或 fixup 命令，如下所示：</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-6-29/85202375.jpg" alt=""></p>
<p>squash 和 fixup 会“向上”合并 — 带有这两个命令的 commit 会被合并到它的前一个 commit 里。在这个例子里， 0835fe2 和 6943e85 会被合并成一个 commit， 38f5e4e 和 af67f82 会被合并成另一个。</p>
<p>如果你选择了 squash， Git 会提示我们给新合并的 commit 一个新的 commit 消息； fixup 则会把合并清单里第一个 commit 的消息直接给新合并的 commit 。 这里，你知道 af67f82 是一个“完了完了….” 的 commit，所以你会留着 38f5e4e as的 commit 消息，但你会给合并了 0835fe2 和 6943e85 的新 commit 编写一个新的消息。</p>
<p>在你保存并退出编辑器的时候，Git 会按从顶部到底部的顺序运用你的 commit。你可以通过在保存前修改 commit 顺序来改变运用的顺序。如果你愿意，你也可以通过如下安排把 af67f82 和 0835fe2 合并到一起：</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-6-29/28442311.jpg" alt=""></p>
<h2 id="修复更早期的-commit"><a href="#修复更早期的-commit" class="headerlink" title="修复更早期的 commit"></a>修复更早期的 commit</h2><p><strong>场景</strong>: 你在一个更早期的 commit 里忘记了加入一个文件，如果更早的 commit 能包含这个忘记的文件就太棒了。你还没有 push，但这个 commit 不是最近的，所以你没法用 commit –amend.</p>
<p><strong>方法</strong>: git commit –squash <sha of="" the="" earlier="" commit=""> 和 git rebase –autosquash -i <even earlier="" sha=""></even></sha></p>
<p><strong>原理</strong>: git commit –squash 会创建一个新的 commit ，它带有一个 commit 消息，类似于 squash! Earlier commit。 (你也可以手工创建一个带有类似 commit 消息的 commit，但是 commit –squash 可以帮你省下输入的工作。)</p>
<p>如果你不想被提示为新合并的 commit 输入一条新的 commit 消息，你也可以利用 git commit –fixup 。在这个情况下，你很可能会用commit –fixup ，因为你只是希望在 rebase 的时候使用早期 commit 的 commit 消息。</p>
<p>rebase –autosquash -i  会激活一个交互式的 rebase 编辑器，但是编辑器打开的时候，在 commit 清单里任何 squash! 和 fixup! 的 commit 都已经配对到目标 commit 上了，如下所示：</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-6-29/95995895.jpg" alt=""></p>
<p>在使用 –squash 和 –fixup 的时候，你可能不记得想要修正的 commit 的 SHA 了— 只记得它是前面第 1 个或第 5 个 commit。你会发现 Git 的 ^ 和 ~ 操作符特别好用。HEAD^ 是 HEAD 的前一个 commit。 HEAD~4 是 HEAD 往前第 4 个 – 或者一起算，倒数第 5 个 commit。</p>
<h2 id="停止追踪一个文件"><a href="#停止追踪一个文件" class="headerlink" title="停止追踪一个文件"></a>停止追踪一个文件</h2><p><strong>场景</strong>: 你偶然把 application.log 加到代码库里了，现在每次你运行应用，Git 都会报告在 application.log 里有未提交的修改。你把 *.login 放到了 .gitignore 文件里，可文件还是在代码库里 — 你怎么才能告诉 Git “撤销” 对这个文件的追踪呢？</p>
<p><strong>方法</strong>: git rm –cached application.log</p>
<p><strong>原理</strong>: 虽然 .gitignore 会阻止 Git 追踪文件的修改，甚至不关注文件是否存在，但这只是针对那些以前从来没有追踪过的文件。一旦有个文件被加入并提交了，Git 就会持续关注该文件的改变。类似地，如果你利用 git add -f 来强制或覆盖了 .gitignore， Git 还会持续追踪改变的情况。之后你就不必用-f  来添加这个文件了。</p>
<p>如果你希望从 Git 的追踪对象中删除那个本应忽略的文件， git rm –cached 会从追踪对象中删除它，但让文件在磁盘上保持原封不动。因为现在它已经被忽略了，你在  git status 里就不会再看见这个文件，也不会再偶然提交该文件的修改了。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p>这就是如何在 Git 里撤销任何操作的方法。要了解更多关于本文中用到的 Git 命令，请查看下面的有关文档：</p>
<ul>
<li><a href="https://git-scm.com/docs/git-checkout" target="_blank" rel="external">checkout</a></li>
<li><a href="https://git-scm.com/docs/git-commit" target="_blank" rel="external">commit</a></li>
<li><a href="https://git-scm.com/docs/git-rebase" target="_blank" rel="external">rebase</a></li>
<li><a href="https://git-scm.com/docs/git-reflog" target="_blank" rel="external">reflog</a></li>
<li><a href="https://git-scm.com/docs/git-reset" target="_blank" rel="external">reset</a></li>
<li><a href="https://git-scm.com/docs/git-revert" target="_blank" rel="external">revert</a></li>
<li><a href="https://git-scm.com/docs/git-rm" target="_blank" rel="external">rm</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识React]]></title>
      <url>http://www.sevenhdu.space/2016/04/02/react-introduction/</url>
      <content type="html"><![CDATA[<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-23/52185478-file_1490201662671_104ae.jpg" alt="React"></p>
<a id="more"></a>
<p>React起源于Facebook的内部项目，由于对市面上的框架都不太满意，就决定自己搞一套，用来架设Instagram网站。</p>
<p>React抛开很多所谓的“最佳实践”，重新思考前端界面的构建方式。<br>官网上是这么描述React的。</p>
<blockquote>
<p>A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACES</p>
</blockquote>
<p>React仅仅是一个构建UI层的js库，却带来了很多开创性的思路来构建前端界面。比如使用JSX来编写页面，以组件化的方式构建页面，运用虚拟DOM来提升性能。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>JSX是React的核心组成部分，它使用XML标记的方式去直接声明界面，界面组件之间可以互相嵌套。作为前端来说，学习JSX的成本很低。</p>
<pre><code class="javascript">import React from &quot;react&quot;;
import { render } from &#39;react-dom&#39;;

render(
    &lt;p&gt;Hello world&lt;/p&gt;
,  document.body);
</code></pre>
<p>JSX中定义属性，添加事件也都很简单。</p>
<pre><code class="javascript">import React, {Component} from &quot;react&quot;;

export class Msg extends Component{
    constructor(props){
        super(props);
    }
    render(){
        let msg = this.props.msg;
        let onClick = this.props.onClick;
        return (
            &lt;div onClick = {onClick}&gt;{msg}&lt;/div&gt;
        )
    }
}

export class SayHello extends Compoent{
    constructor(props){
        super(props);
    }
    sayHello(){
        alert(&quot;Hello!&quot;);
    }
    render(){
        return (
            &lt;Msg msg=&quot;Hello, world&quot; onClick= {this.sayHello.bind(this)}/&gt;
        )
    }
}
</code></pre>
<p>子组件通过props获取父组件传递的属性，包括事件函数。</p>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>组件并不是一个新的概念，它意味着某个独立功能或界面的封装，达到复用、或是业务逻辑分离的目的。React这样理解界面组件：</p>
<blockquote>
<p><strong>所谓组件，就是状态机器</strong></p>
<p>React将用户界面看做简单的状态机器。当组件处于某个状态时，那么就输出这个状态对应的界面。通过这种方式，就很容易去保证界面的一致性。</p>
<p>在React中，你简单的去更新某个组件的状态，然后输出基于新状态的整个界面。React负责以最高效的方式去比较两个界面并更新DOM树。</p>
</blockquote>
<p>所以对组件的管理其实就是对状态的管理。</p>
<h2 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h2><p>虚拟DOM，顾名思义不是真正的DOM，它只是保存在内存中的一种数据结构，在JS里其实就是对象。其高效的Diff算法让我们可以无需担心性能问题而”毫无顾忌”的随时“刷新”整个页面，由虚拟DOM来确保只对界面上真正变化的部分进行实际的DOM操作。</p>
<p>即给定任意两棵树，找到最少的转换步骤。但是标准的的Diff算法复杂度需要O(n^3)，这显然无法满足性能要求。要达到每次界面都可以整体刷新界面的目的，势必需要对算法进行优化。这看上去非常有难度，然而Facebook工程师却做到了，他们结合Web界面的特点做出了两个简单的假设，使得Diff算法复杂度直接降低到O(n)</p>
<ul>
<li>两个相同组件产生类似的DOM结构，不同的组件产生不同的DOM结构；</li>
<li>对于同一层次的一组子节点，它们可以通过唯一的id进行区分。</li>
</ul>
<p>算法上的优化是React整个界面Render的基础，事实也证明这两个假设是合理而精确的，保证了整体界面构建的性能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的几点，可以对React有个大概的了解。但要在项目中使用React，还需要了解它的生命周期，以及Facebook官方推荐使用的数据管理方式Flux(单向数据流)。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://facebook.github.io/react/" target="_blank" rel="external">React</a></li>
<li><a href="http://www.infoq.com/cn/articles/react-art-of-simplity?utm_source=articles_about_dive-into-react&amp;utm_medium=link&amp;utm_campaign=dive-into-react" target="_blank" rel="external">深入浅出React（一）：React的设计哲学 - 简单之美</a></li>
<li><a href="http://www.infoq.com/cn/articles/react-dom-diff" target="_blank" rel="external">深入浅出React（四）：虚拟DOM Diff算法解析</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Atom编辑器快捷键大全]]></title>
      <url>http://www.sevenhdu.space/2016/03/24/Atom-shortcut-keys/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：futantan<br>原文地址：<a href="https://github.com/futantan/atom" target="_blank" rel="external">https://github.com/futantan/atom</a></p>
</blockquote>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-24/13908820-file_1487866405842_16c03.png" alt=""></p>
<a id="more"></a>
<h2 id="文件切换"><a href="#文件切换" class="headerlink" title="文件切换"></a>文件切换</h2><p><code>ctrl-shift-s</code>  保存所有打开的文件<br><code>cmd-shift-o</code>  打开目录<br><code>cmd-\</code>   显示或隐藏目录树<br><code>ctrl-0</code>   焦点移到目录树<br>目录树下，使用a，m，delete来增加，修改和删除<br><code>cmd-t</code>或<code>cmd-p</code> 查找文件<br><code>cmd-b</code> 在打开的文件之间切换<br><code>cmd-shift-b</code> 只搜索从上次git commit后修改或者新增的文件</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>（等价于上下左右）<br><code>ctrl-p</code> 前一行<br><code>ctrl-n</code> 后一行<br><code>ctrl-f</code> 前一个字符<br><code>ctrl-b</code> 后一个字符  </p>
<p><code>alt-B</code>, <code>alt-left</code> 移动到单词开始<br><code>alt-F</code>, <code>alt-right</code> 移动到单词末尾  </p>
<p><code>cmd-right</code>, <code>ctrl-E</code> 移动到一行结束<br><code>cmd-left</code>, <code>ctrl-A</code>  移动到一行开始  </p>
<p><code>cmd-up</code> 移动到文件开始<br><code>cmd-down</code> 移动到文件结束  </p>
<p><code>ctrl-g</code> 移动到指定行 row:column 处</p>
<p><code>cmd-r</code> 在方法之间跳转</p>
<h2 id="目录树操作"><a href="#目录树操作" class="headerlink" title="目录树操作"></a>目录树操作</h2><p><code>cmd-\</code> 或者 <code>cmd-k cmd-b</code> 显示(隐藏)目录树<br><code>ctrl-0</code> 焦点切换到目录树(再按一次或者<code>Esc</code>退出目录树)<br><code>a</code> 添加文件<br><code>d</code> 将当前文件另存为(duplicate)<br><code>i</code> 显示(隐藏)版本控制忽略的文件<br><code>alt-right</code> 和 <code>alt-left</code> 展开(隐藏)所有目录<br><code>ctrl-al-]</code> 和 <code>ctrl-al-[</code> 同上<br><code>ctrl-[</code> 和 <code>ctrl-]</code> 展开(隐藏)当前目录<br><code>ctrl-f</code> 和 <code>ctrl-b</code> 同上<br><code>cmd-k h</code> 或者 <code>cmd-k left</code> 在左半视图中打开文件<br><code>cmd-k j</code> 或者 <code>cmd-k down</code> 在下半视图中打开文件<br><code>cmd-k k</code> 或者 <code>cmd-k up</code> 在上半视图中打开文件<br><code>cmd-k l</code> 或者 <code>cmd-k right</code> 在右半视图中打开文件<br><code>ctrl-shift-C</code> 复制当前文件绝对路径</p>
<h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p><code>cmd-F2</code> 在本行增加书签<br><code>F2</code> 跳到当前文件的下一条书签<br><code>shift-F2</code> 跳到当前文件的上一条书签<br><code>ctrl-F2</code> 列出当前工程所有书签  </p>
<h2 id="选取"><a href="#选取" class="headerlink" title="选取"></a>选取</h2><blockquote>
<p>大部分和导航一致，只不过加上shift  </p>
</blockquote>
<p><code>ctrl-shift-P</code>  选取至上一行<br><code>ctrl-shift-N</code>  选取至下一样<br><code>ctrl-shift-B</code>  选取至前一个字符<br><code>ctrl-shift-F</code>  选取至后一个字符<br><code>alt-shift-B</code>, <code>alt-shift-left</code>  选取至字符开始<br><code>alt-shift-F</code>, <code>alt-shift-right</code>  选取至字符结束<br><code>ctrl-shift-E</code>, <code>cmd-shift-right</code>  选取至本行结束<br><code>ctrl-shift-A</code>, <code>cmd-shift-left</code>  选取至本行开始<br><code>cmd-shift-up</code>  选取至文件开始<br><code>cmd-shift-down</code>  选取至文件结尾<br><code>cmd-A</code>  全选<br><code>cmd-L</code>  选取一行，继续按回选取下一行<br><code>ctrl-shift-W</code>  选取当前单词  </p>
<h2 id="编辑和删除文本"><a href="#编辑和删除文本" class="headerlink" title="编辑和删除文本"></a>编辑和删除文本</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>ctrl-T</code> 使光标前后字符交换<br><code>cmd-J</code> 将下一行与当前行合并<br><code>ctrl-cmd-up</code>, <code>ctrl-cmd-down</code> 使当前行向上或者向下移动<br><code>cmd-shift-D</code> 复制当前行到下一行<br><code>cmd-K</code>, <code>cmd-U</code> 使当前字符大写<br><code>cmd-K</code>, <code>cmd-L</code> 使当前字符小写<br><code>cmd-shift-P</code> 搜索命令  </p>
<h3 id="删除和剪切"><a href="#删除和剪切" class="headerlink" title="删除和剪切"></a>删除和剪切</h3><p><code>ctrl-shift-K</code> 删除当前行<br><code>cmd-backspace</code> 删除到当前行开始<br><code>cmd-fn-backspace</code> 删除到当前行结束<br><code>ctrl-K</code> 剪切到当前行结束<br><code>alt-backspace</code> 或 <code>alt-H</code> 删除到当前单词开始<br><code>alt-delete</code> 或 <code>alt-D</code> 删除到当前单词结束  </p>
<h3 id="多光标和多处选取"><a href="#多光标和多处选取" class="headerlink" title="多光标和多处选取"></a>多光标和多处选取</h3><p><code>cmd-click</code> 增加新光标<br><code>cmd-shift-L</code> 将多行选取改为多行光标<br><code>ctrl-shift-up</code>, <code>ctrl-shift-down</code> 增加上（下）一行光标<br><code>cmd-D</code> 选取文档中和当前单词相同的下一处<br><code>ctrl-cmd-G</code> 选取文档中所有和当前光标单词相同的位置  </p>
<h3 id="括号跳转"><a href="#括号跳转" class="headerlink" title="括号跳转"></a>括号跳转</h3><p><code>ctrl-m</code> 相应括号之间，html tag之间等跳转<br><code>ctrl-cmd-m</code> 括号(tag)之间文本选取<br><code>alt-cmd-.</code> 关闭当前XML/HTML tag  </p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p><code>ctrl-shift-U</code> 调出切换编码选项  </p>
<h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><p><code>cmd-F</code> 在buffer中查找<br><code>cmd-shift-f</code> 在整个工程中查找  </p>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p><code>alt-shift-S</code> 查看当前可用代码片段  </p>
<blockquote>
<p>在<code>~/.atom</code>目录下<code>snippets.cson</code>文件中存放了你定制的snippets  </p>
</blockquote>
<p><a href="https://atom.io/docs/v1.0.0/using-atom-snippets" target="_blank" rel="external">定制说明</a>  </p>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p><code>ctrl-space</code> 提示补全信息  </p>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p><code>alt-cmd-[</code> 折叠<br><code>alt-cmd-]</code> 展开<br><code>alt-cmd-shift-{</code> 折叠全部<br><code>alt-cmd-shift-}</code> 展开全部<br><code>cmd-k cmd-N</code> 指定折叠层级 N为层级数  </p>
<h2 id="文件语法高亮"><a href="#文件语法高亮" class="headerlink" title="文件语法高亮"></a>文件语法高亮</h2><p><code>ctrl-shift-L</code> 选择文本类型  </p>
<h2 id="使用Atom进行写作"><a href="#使用Atom进行写作" class="headerlink" title="使用Atom进行写作"></a>使用Atom进行写作</h2><p><code>ctrl-shift-M</code> Markdown预览<br>可用代码片段</p>
<blockquote>
<p>b, legal, img, l, i, code, t, table</p>
</blockquote>
<h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><p><code>cmd-alt-Z</code> checkout HEAD 版本<br><code>cmd-shift-B</code> 弹出untracked 和 modified文件列表<br><code>alt-g down</code> <code>alt-g up</code> 在修改处跳转<br><code>alt-G D</code> 弹出diff列表<br><code>alt-G O</code> 在github上打开文件<br><code>alt-G G</code> 在github上打开项目地址<br><code>alt-G B</code> 在github上打开文件blame<br><code>alt-G H</code> 在github上打开文件history<br><code>alt-G I</code> 在github上打开issues<br><code>alt-G R</code> 在github打开分支比较<br><code>alt-G C</code> 拷贝当前文件在gihub上的网址</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Webpack 入门]]></title>
      <url>http://www.sevenhdu.space/2016/03/22/webpack-introduction/</url>
      <content type="html"><![CDATA[<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-22/18733749-file_1490166715919_842e.png" alt="什么是Webpack"></p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Webpack是一个模块打包器，高度可配置。它会根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。</p>
<p>Webpack将项目中用到的一切静态资源都视为模块，模块之间可以相互依赖。Webpack对它们进项统一的管理和打包。</p>
<p>Webpack有四个比较重要的概念：入口(Entry)、出口(Output)、加载器(Loaders)、插件(Plugins)。</p>
<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><p>Entry定义了入口文件比如entry.js。Webpack 会分析入口文件，解析包含依赖关系的各个文件。这些文件（模块）都打包到出口文件（output定义的文件）例如bundle.js 。Webpack 会给每个模块分配一个唯一的 id 并通过这个 id 索引和访问模块。在页面启动时，会先执行 entry.js 中的代码，其它模块会在运行 require 的时候再执行。</p>
<pre><code class="javascript">module.exports = {
    entry: &#39;entry.js&#39;
};
</code></pre>
<p>更多应用应用场景可以参考<a href="https://doc.webpack-china.org/concepts/entry-points/" target="_blank" rel="external">这里</a></p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>出口定义了Webpack打包完以后生成的文件。常用的有这几个属性：<code>path</code>、<code>publicPath</code>、<code>filename</code>。<br><code>path</code>对应一个绝对路径，此路径是一次性打包的目录。<br><code>publicPath</code>被许多Webpack的插件用于在生产模式下更新内嵌到css、html文件里的url值。<br><code>filename</code>出口的文件名</p>
<pre><code class="javascript">const path = require(&#39;path&#39;);

module.exports = {
    entry: &#39;entry.js&#39;,
    output: {
        path: path.resolve(__dirname, &#39;dist&#39;),
        publicPath : &quot;/&quot;,
        filename: &#39;bundle.js&#39;
    }
};
</code></pre>
<p>更多应用应用场景可以参考<a href="https://doc.webpack-china.org/concepts/output/" target="_blank" rel="external">这里</a></p>
<h2 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h2><p>Webpack本身只能处理 JavaScript 模块，如果要处理其他类型的文件，就需要使用 loader 进行转换。</p>
<p>Loader可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require或者import来加载任何类型的模块或文件，比如CoffeeScript、JSX、LESS或图片。</p>
<p>而转换对应的文件，只要通过npm安装对应的loader，然后在webpack.config.js中配置好。之后的一切就可以交给Webpack。</p>
<pre><code class="javascript">{
    loaders : [{
        test : /\.(less|css)$/,
        loader: &#39;style!css!less&#39;
    },{
        test : /\.(png|jpg|gif|woff|svg|eot|ttf)\??.*$/,
        loader : &quot;url?limit=100&amp;name=/img/[name]-[hash:8].[ext]&quot;
    },{
        test : /\.jsx?$/,
        loader : &quot;babel&quot;,
        include : [APP_PATH,MOCK_PATH],
        exclude : NODE_PATH,
        query : {
            presets : [&quot;es2015&quot;, &quot;react&quot;]
        }
    }]
}
</code></pre>
<p>多个loader可以用在同一个文件上并且被链式调用。链式调用时从右到左执行且loader之间用“!”来分割。</p>
<p><a href="https://webpack.github.io/docs/list-of-loaders.html" target="_blank" rel="external">这是</a>是loader列表，相当丰富。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>插件可以完成很多loader不能完成的功能。比如压缩文件、拷贝文件、提供公共资源等等之类的。<br>以压缩文件作为例子。</p>
<pre><code class="javascript">plugins: [
    new webpack.optimize.UglifyJsPlugin({minimize: true})
]
</code></pre>
<p>加载器和插件搭配，可以完成很多工作。而且安装也很方便，通过npm就可以轻轻松松安装。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Webpack是前端模块管理和打包工具，配合loader和plugin，配置简单，功能强大。尽管它不是万能的，有时候也要配合gulp来完成其他功能，但依然值得你花时间去学习、使用它。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://zhaoda.net/webpack-handbook/index.html" target="_blank" rel="external">Webpack 中文指南</a></li>
<li><a href="https://webpack.github.io/" target="_blank" rel="external">Webpack 官网</a></li>
<li><a href="https://doc.webpack-china.org/" target="_blank" rel="external">Webpack 中国</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于CSS Transition,你需要知道的一切]]></title>
      <url>http://www.sevenhdu.space/2015/07/20/all-you-need-to-know-about-css-transitions/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：Alex MacCaw<br>原文地址：<a href="https://blog.alexmaccaw.com/css-transitions" target="_blank" rel="external">All you need to know about CSS Transitions</a></p>
</blockquote>
<p>CSS3的Transition能在Web页面构建出简单而又优雅的动画效果，不过再一次使用它的时候，仍然还有一些需要说明。<br>这篇文章中，我将探索一下transition中比较复杂的部分。，从链式过渡、事件到硬件加速以及动画函数。<br>让浏览器来控制动画序列，能优化性能，减少绘制，而且能将部分工作交给GPU处理。</p>
<a id="more"></a>
<h2 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h2><p>目前，几乎所有版本的 Firefox, Safari, Chrome 包括 IE10 及以上版本都支持 transition 属性。即使浏览器不支持，属性也会立即应用，优雅降级。<br>动画与渐变特效在 Safari 和 Chrome 下仍然需要添加 -webkit 前缀，不过很快也会不需要了。</p>
<h2 id="应用过渡"><a href="#应用过渡" class="headerlink" title="应用过渡"></a>应用过渡</h2><p>可以使用CSS伪类来应用transition，例如<code>:hover</code>。使用时指定变化的属性名，过渡时间，以及其中一个默认动画函数，<code>linear</code>。</p>
<pre><code class="css">.element{
    height: 100px;
    transition: height 2s linear;
}

.element:hover{
    height: 200px;
}
</code></pre>
<p>当<code>:hover</code>伪类激活的时候，则元素的高度将在2秒以内从100px匀速过渡到200px。<br>浏览器默认过渡属性为 all （全部属性），动画函数为 ease，因此如果没特殊要求，只需定义变化的时间<br>用伪类来激活过渡效果，将有很多限制，很明显它不太灵活。解决方法就是用程序控制来添加、删除过渡类。</p>
<pre><code class="css">.element{
    opacity: 0;
    transform: scale(0.95) translate3d(0, 100%, 0);
    transition: transform 400s ease, opacity 400ms ease;
}

.element.active{
    opacity: 1;
    transform: scale(1) translate3d(0, 0, 0);
}

.element.inactive{
    opacity: 0;
    transform: scale(1) translate3d(0, 0, 0);
}
</code></pre>
<pre><code class="javascript">//js with jQuery
var active = fucntion(){
    $(&#39;.element&#39;).removeClass(&#39;inactive&#39;).addClass(&#39;active&#39;);
};

var inactive = function(){
    $(&#39;.element&#39;).removeClass(&#39;active&#39;).addClass(&#39;inactive&#39;);
}
</code></pre>
<p>上面的例子，有两个不同的过渡，激活时向上滑动，失效时淡出。JavaScript所做的事就是切换两个类<code>active</code>和<code>inactive</code>。</p>
<h2 id="过渡渐变"><a href="#过渡渐变" class="headerlink" title="过渡渐变"></a>过渡渐变</h2><p>不是所有的CSS属性都可以过渡，而且只能从一个绝对值变化到另一个绝对值。举个例子，<code>height</code>属性从<code>0px</code>到<code>atuo</code>将不会出现过渡效果。浏览器无法计算中间的过渡值，所以属性变化是瞬间的。Oli Studholme就列了下可过渡的<a href="http://oli.jp/2010/css-animatable-properties/" target="_blank" rel="external">属性列表</a>。</p>
<p>还有一个过渡会失效的属性是背景渐变（尽管纯背景颜色是支持的）。这个限制没有技术上的原因，只是还要等待一段时间来让浏览器实现对其的支持。</p>
<p>当然，还有一些好的变通方法。首先添加一个有透明度的渐变，然后过渡背景颜色。比如</p>
<pre><code class="css">.panel{
    background-color: #000;
    background-image: linear-gradient(rgba(255, 255, 0, 0.4), #FAFAFA);
    transition: background-color 400ms ease;
}
.panel:hover{
    background-color: #DDD
}
</code></pre>
<iframe height="265" scrolling="no" title="ZerLqj" src="//codepen.io/SevenHDU/embed/ZerLqj/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/ZerLqj/" target="_blank" rel="external">ZerLqj</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>如果渐变是连续不断的，则可以通过过渡<code>background-position</code>来达到效果。</p>
<iframe height="265" scrolling="no" title="peaRMK" src="//codepen.io/SevenHDU/embed/peaRMK/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/peaRMK/" target="_blank" rel="external">peaRMK</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<p>除此之外，还可以创建两个元素，一个覆盖另外一个，然后过渡他们的<code>opacity</code>属性。</p>
<pre><code class="css">.element {  
  width: 100px;  
  height: 100px;  
  position: relative;
  background: linear-gradient(#C7D3DC,#5B798E);    
}  

.element .inner {
  content: &#39;&#39;;
  position: absolute;
  left: 0; top: 0; right: 0; bottom: 0;
  background: linear-gradient(#DDD, #FAFAFA);          
  opacity: 0;
  transition: opacity 1s linear;
}

.element:hover .inner {
  opacity: 1;
}
</code></pre>
<p>但是，这样需要额外的标签，上一层的元素也会获取鼠标事件。所以，如果这里能用 <code>:before</code>，<code>:after</code> 伪类是最理想的，可惜目前只有 Firefox 支持伪类变化。Eliott Sprehn 正在努力让 webkit 也支持伪类变化，这一功能很快也会在 Safari Chrome 上实现。</p>
<h2 id="硬件加速"><a href="#硬件加速" class="headerlink" title="硬件加速"></a>硬件加速</h2><p>过渡某些属性，比如<code>left</code>、<code>margin</code>，浏览器会在每一帧重新计算样式。会引起不必要的重绘，成本相当昂贵，尤其是有很多元素的时候。在移动设置上，这个后果更加明显。</p>
<p>解决方法就是交给GPU来处理，用CSS的<code>transform</code>就可以触发。简单地说，就是将元素转化为图片再执行过渡效果，避免任何样式的重计算，这就大大提高了性能。强制浏览器开启硬件加速最简单的方法就是用<code>transform: translate3d(0,0,0)</code>。</p>
<p>不过，这不是解决性能问题的完美方法，它本身也有问题。在必要的时候，才开启硬件加速，不要盲目用到每一个元素上。<br>举个例子，硬件加速会引起微妙的字体问题，比如<code>font</code>会损失<code>weight</code>。原因就是硬件加速过程中不会对字体启用抗锯齿特效，避免这个问题只能禁用 <code>font-smoothing: antialiased;</code>。</p>
<p>另外，不同的浏览器使用不同的硬件加速库，这可能引起跨浏览器问题。比如，Chrome和Safari都基于WebKit，不过Chrome使用Skia来处理图形渲染，Safari使用CoreGraphics。区别是细微，但却是实实在在存在的。</p>
<p>使用Chrome自带的开发者工具，展示了当前页面所有的重绘。在<code>about:flags</code>中启用Composited Render Layer Borders，就可以看到由GPU操纵的层。减少绘画的关键就是批处理更新DOM，而且尽可能交由GPU处理。</p>
<p>如果硬件加速在不同浏览器中有显示问题，比如闪烁或者颤抖，那就放弃使用<code>transform3d()</code>属性。</p>
<h2 id="Clipping"><a href="#Clipping" class="headerlink" title="Clipping"></a>Clipping</h2><p>为了充分利用GPU渲染能力，使用CSS的<code>transform</code>而不是类似<code>width</code>的属性来避免重新计算。假如要变化元素的width，你将会怎么做？答案是使用clipping（术语，only drawing things that will be visible to the viewer）。</p>
<p>下面的例子，搜索框会有两个过渡状态，</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-21/87876292-file_1490026519380_1f4c.png" alt=""></p>
<p>搜索框拉宽，使用<code>translate3d</code>属性使元素在X轴上拉长，而不是<code>width</code>。</p>
<pre><code class="css">.clipped {
  overflow: hidden;
  position: relative;
}

.clipped .clip {
  right: 0px;
  width: 45px;
  height: 45px;
  background: url(/images/clip.png) no-repeat
}

input:focus {
  -webkit-transform: translate3d(-50px, 0, 0);
}
</code></pre>
<p>这样每一帧都不会重新计算元素的宽度，过渡将更加平稳丝滑，性能更好。</p>
<h2 id="动画函数"><a href="#动画函数" class="headerlink" title="动画函数"></a>动画函数</h2><p>到目前为止，我们已经使用了一些浏览器预置的动画函数：<code>lienar</code>，<code>ease</code>，<code>ease-in</code>，<code>ease-out</code>，<code>ease-in-out</code>。更复杂的话就是使用cubic-bezier曲线自定义动画函数。例如</p>
<pre><code class="css">transition: -webkit-transform 1s cubic-bezier(0.17,0.67,0.69,1.33);
</code></pre>
<p>有两个现成工具，可以帮你使用cubic-bezier曲线自定义动画函数：<a href="http://easings.net/" target="_blank" rel="external">Pre-defined Curves</a>和<a href="http://cubic-bezier.com/" target="_blank" rel="external">Graphing Tool</a>。</p>
<h2 id="程序化过渡效果"><a href="#程序化过渡效果" class="headerlink" title="程序化过渡效果"></a>程序化过渡效果</h2><p>写CSS transition非常好，但有时候需要更好的控制，特别是链式过渡。我们不仅要通过JavaScript来调用，还要定义它们。</p>
<p>CSS transition中有一个神奇的all属性，保证了任何改变的属性都可以过渡（前提这个属性是可过渡的）。</p>
<pre><code class="javascript">var defaults = {
  duration: 400,
  easing: &#39;&#39;
};

$.fn.transition = function (properties, options) {
  options = $.extend({}, defaults, options);
  properties[&#39;webkitTransition&#39;] = &#39;all &#39; + options.duration + &#39;ms &#39; + options.easing;
  $(this).css(properties);
};
</code></pre>
<p>然后用 jQuery 函数 $.fn.transition 调用变化样式。</p>
<pre><code class="javascript">$(&#39;.element&#39;).transition({background: &#39;red&#39;});
</code></pre>
<h2 id="transiton回调"><a href="#transiton回调" class="headerlink" title="transiton回调"></a>transiton回调</h2><p>下一步就是使用transition回调。在基于WebKit的浏览器中，可以监听<code>webkitTransitionEnd</code>事件。其他浏览器，只要改下事件名称前缀也是可以的。</p>
<pre><code class="javascript">var callback = function () {
    // ...
}

$(this).one(&#39;webkitTransitionEnd&#39;, callback)
$(this).css(properties);
</code></pre>
<p>注意有时候事件不会触发，通知都是因为属性没有改变或者绘画没有触发。为了保证执行这个回调，可以在<code>setTimeout</code>中手动触发事件。</p>
<pre><code class="javascript">$.fn.emulateTransitionEnd = function(duration) {
    var called = false, $el = this;
    $(this).one(&#39;webkitTransitionEnd&#39;, function() { called = true; });
    var callback = function() {
        if (!called) $($el).trigger(&#39;webkitTransitionEnd&#39;);
    };
    setTimeout(callback, duration);
};
</code></pre>
<p>现在我们就可以在设置元素CSS之前滴啊用<code>$.fn.emulateTransitionEnd()</code>，保证过渡以及回调都能触发。</p>
<pre><code class="javascript">$(this).one(&#39;webkitTransitionEnd&#39;, callback);
$(this).emulateTransitionEnd(options.duration + 50);
$(this).css(properties);
</code></pre>
<h2 id="链式过渡"><a href="#链式过渡" class="headerlink" title="链式过渡"></a>链式过渡</h2><p>因此现在我们可以通过代码应用过渡，结束后执行回调，这样过渡效果就可以以排队的方式一个一个执行。而jQuery库中存在同样的方法。</p>
<p>针对队列，jQuery提供了两个主要的函数方法，<code>$.fn.queue(callback)</code>和<code>$.fn.dequeue()</code>。前者是将回调添加到队列中，而后者是执行队列中的下一项。</p>
<p>换句话说，我们需要在队列回调中设置CSS的过渡，当过渡完成时确保调用了<code>$.fn.dequeue</code>。</p>
<pre><code class="javascript">var $el = $(this);
$el.queue(function(){
    $el.one(&#39;webkitTransitionEnd&#39;, function(){
        $el.dequeue();
    });
    $el.css(properties);
});
</code></pre>
<p>这个例子很简单，让我们用jQuery的<code>delay()</code>函数来构建复杂的链式动画。</p>
<pre><code class="javascript">$(&#39;.element&#39;).transition({left: &#39;20px&#39;})
             .delay(200)
             .transition({background: &#39;red&#39;});
</code></pre>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>一般过渡时，是有两组CSS属性。从起始属性过渡到最终属性。</p>
<pre><code class="javascript">$(&#39;.element&#39;).css({left: &#39;10px&#39;})
             .transition({left: &#39;20px&#39;});
</code></pre>
<p>然后，你会发现当应用两组CSS属性，一组紧挨着一组，浏览器会尝试优化这些属性的变化，忽略初始的属性，阻止过渡变化。在后台，浏览器在重绘前批处理样式的变化，这样会加快渲染速度，但有时也有不利的影响。</p>
<p>解决办法是利用DOM元素的<code>offsetHeight</code>属性让浏览器在两套样式之间强制重绘。</p>
<pre><code class="javascript">$.fn.redraw = function(){
    $(this).each(function(){
        var redraw = this.offsetHeight;
    });
};
</code></pre>
<p>这个方法在大多数浏览器下都能吃工作正常，但在Android下就不行，可以使用timeout或者激活一个class。</p>
<pre><code class="javascript">$(&#39;.element&#39;).css({left: &#39;10px&#39;})
             .redraw()
             .transition({left: &#39;20px&#39;});
</code></pre>
<h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>草案一直在积极的制定，而接下来的规格说明看起来真的很有希望。草种中包含新的Javascript API应对现在的局限性，给开发者更灵活的空间。</p>
<p>事实上，你可以在github上找到这些新API的(垫片)[<a href="https://github.com/web-animations/web-animations-js]。" target="_blank" rel="external">https://github.com/web-animations/web-animations-js]。</a></p>
<pre><code class="javascript">var anim = new Animation(elem, { left: &#39;100px&#39; }, 3);
anim.play();
</code></pre>
<p>使用这个API可以同步动画，提供个性化的动画函数，以及完成以后的回调。这都是令人相当兴奋的。</p>
<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2><p>目前为止，希望你已经深入的了解了CSS的<code>transition</code>属性，以及如何组合简单的API制作丰富的动画效果。</p>
<p>文中大多数js 例子来源于GFX，一个jQuery的CSS transtion库。里面内置了很多效果，例如滑动、爆炸、3D翻转。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS3中的transform]]></title>
      <url>http://www.sevenhdu.space/2015/06/15/CSS3-transform/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>transform可以对元素应用2D或3D变换，包括移动（translate）、缩放（scale）、倾斜（skew）、旋转（rotate）。通过transform可以实现很多动画效果。</p>
<a id="more"></a>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><table>
<thead>
<tr>
<th style="text-align:left">例子</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">translate(50px, 100px)</td>
<td style="text-align:right">元素向右平移50px,向下平移100px</td>
</tr>
<tr>
<td style="text-align:left">scale(2, 3)</td>
<td style="text-align:right">元素宽度扩大2倍，高度扩大3倍</td>
</tr>
<tr>
<td style="text-align:left">skew(20deg)</td>
<td style="text-align:right">元素在X轴倾斜20°</td>
</tr>
<tr>
<td style="text-align:left">rotate(60deg)</td>
<td style="text-align:right">元素顺时针旋转60°</td>
</tr>
</tbody>
</table>
<p>可以同一个元素使用多个不同类型的变换，只要变换之间以空格隔开</p>
<pre><code class="css">transform: translate(50px, 100px) scale(2, 3) rotate(60deg);
</code></pre>
<p>还有高级用法矩阵matrix，它可以将多个变换整合到一个变换函数中。<br>比如<br><code>rotate(45deg) translate(24px,25px)</code><br>对应<br><code>matrix(0.707107, 0.707107, -0.707107, 0.707107, -0.707107, 34.6482)</code><br>有这样一个转换的网站，可以自己试试看。<a href="http://meyerweb.com/eric/tools/matrix/" target="_blank" rel="external">传送门</a></p>
<p>想深入理解可以看看这篇文章<a href="http://www.zhangxinxu.com/wordpress/2012/06/css3-transform-matrix-%E7%9F%A9%E9%98%B5/" target="_blank" rel="external">理解CSS3 transform中的Matrix(矩阵)</a></p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>直接上例子，为了让变换不那么生硬，加了过渡属性transition。</p>
<iframe height="265" scrolling="no" title="CSS3 transform" src="//codepen.io/SevenHDU/embed/YZxROr/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/SevenHDU/pen/YZxROr/" target="_blank" rel="external">CSS3 transform</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h2 id="transform-origin的玄机"><a href="#transform-origin的玄机" class="headerlink" title="transform-origin的玄机"></a>transform-origin的玄机</h2><p>transfrom属性和transform-origin是息息相关的。transform是以tranform-origin的值作为原点进行变换的，默认是中心点。<br>看下面的例子。</p>
<iframe height="300" scrolling="no" title="Transform-origin" src="//codepen.io/SevenHDU/embed/wJrggy/?height=300&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/wJrggy/" target="_blank" rel="external">Transform-origin</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h2 id="在桌面端和移动端用CSS开启硬件加速"><a href="#在桌面端和移动端用CSS开启硬件加速" class="headerlink" title="在桌面端和移动端用CSS开启硬件加速"></a>在桌面端和移动端用CSS开启硬件加速</h2><p>浏览器检测到元素应用某些CSS属性时，会开启硬件加速。其中一个就是3D变换。<br>例如</p>
<pre><code class="css">.ele {
   -webkit-transform: translate3d(250px,250px,250px)
   rotate3d(250px,250px,250px,-120deg)
   scale3d(0.5, 0.5, 0.5);
}
</code></pre>
<p>可是在一些情况下，我们并不需要对元素应用3D变换的效果，那怎么办呢？这时候我们可以使用个小技巧“欺骗”浏览器来开启硬件加速。</p>
<pre><code class="css">.ele {
   -webkit-transform: translateZ(0)
}
</code></pre>
<p>硬件加速在移动端尤其有用。<br>通过开启GPU硬件加速虽然可以提升动画渲染性能或解决一些棘手问题，但使用仍需谨慎，使用前一定要进行严谨的测试，否则它反而会大量占用浏览网页用户的系统资源，尤其是在移动端，肆无忌惮的开启GPU硬件加速会导致大量消耗设备电量，降低电池寿命等问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Transforms/Using_CSS_transforms" target="_blank" rel="external">Using CSS transforms</a></li>
<li><a href="https://css-tricks.com/almanac/properties/t/transform/" target="_blank" rel="external">transform</a></li>
<li><a href="http://www.cnblogs.com/PeunZhang/p/3510083.html" target="_blank" rel="external">用CSS开启硬件加速来提高网站性能</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS选择器的优先级]]></title>
      <url>http://www.sevenhdu.space/2015/03/19/css-selectors-priority/</url>
      <content type="html"><![CDATA[<p>前几天面试的时候，被问到一个关于CSS选择器优先级的问题。</p>
<p>题目大概是这样的：<br>对以下CSS选择器进行排序：<br><a id="more"></a></p>
<ul>
<li>ID选择器</li>
<li>类选择器</li>
<li>元素选择器</li>
<li>属性选择器</li>
<li>伪类选择器</li>
<li>伪对象选择器</li>
<li>通配符选择器</li>
</ul>
<p>ID、类、标签这3个选择器的权重比较熟悉，其他几种选择器或多或少不是很确定。所以回来以后特地查了下<a href="https://www.w3.org/TR/CSS21/cascade.html#specificity" target="_blank" rel="external">W3C官网</a>，对CSS选择器优先级算是有了更深的认识。</p>
<p>CSS选择器通过a、b、c、d四个维度值来计算特征值。</p>
<table>
<thead>
<tr>
<th style="text-align:left">选择器类型</th>
<th style="text-align:right">维度（a,b,c,d）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">行内样式</td>
<td style="text-align:right">1,0,0,0</td>
</tr>
<tr>
<td style="text-align:left">ID选择器</td>
<td style="text-align:right">0,1,0,0</td>
</tr>
<tr>
<td style="text-align:left">类选择器、属性选择器、伪类选择器</td>
<td style="text-align:right">0,0,1,0</td>
</tr>
<tr>
<td style="text-align:left">元素选择器，伪元素选择器</td>
<td style="text-align:right">0,0,0,1</td>
</tr>
<tr>
<td style="text-align:left">通用元素选择器（*）</td>
<td style="text-align:right">0,0,0,0</td>
</tr>
</tbody>
</table>
<p>规则也很简单，同一维度比较个数，个数多的优先级高，相同个数则比较下一级的个数，全部都相同，则后定义的优先级高。不过如果属性中使用了!important，则优先级提高到最高。<br>因此，最后的结论就是<br><code>!important&gt;行内&gt;ID&gt;类、属性、伪类&gt;元素、伪元素&gt;通配符</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS中的伪类和伪元素]]></title>
      <url>http://www.sevenhdu.space/2015/03/05/css-pseudo-class-and-pseudo-elments/</url>
      <content type="html"><![CDATA[<p>先看<code>W3C</code>的定义<br>. <strong>CSS伪类</strong> 用于向某些选择器添加特殊的效果<br>. <strong>CSS伪元素</strong> 用于向某些选择器设置特殊效果</p>
<p>光看定义，其实还是云里雾里的，所以还是要深入研究下才能搞明白他们的作用。</p>
<a id="more"></a>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪类与类相似，但又没有类附加标签上。伪类分为UI伪类和结构化伪类。</p>
<h3 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h3><ul>
<li>:link(将样式添加到未被访问的链接上)</li>
<li>:visted(将样式已添加到访问的链接上)</li>
<li>:hover(将样式添加到鼠标悬浮的元素上)</li>
<li>:active(将样式添加到被激活的元素上)</li>
<li>:focus(将样式添加到被选中的元素上)</li>
</ul>
<h3 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h3><ul>
<li>:first-child(将样式添加到第一个子元素上)</li>
<li>:last-child(将样式添加到最后一个子元素上)</li>
</ul>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素是在文档中若有实无的元素。<br>主要有以下几种</p>
<ul>
<li>:first-letter(将样式添加到第一个字母)</li>
<li>:first-line(将样式添加到第一行)</li>
<li>:before(在某些元素前面插入某些内容)</li>
<li>:after(在某些元素后面插入某些内容)</li>
</ul>
<p>看到:after，大家脑子里应该都能想到那个经典的清除浮动的CSS的吧。没错，就是这个。</p>
<pre><code class="css">.clearfix:after {
    content:&quot;.&quot;;
    display:block;
    height:0;
    visibility:hidden;
    clear:both;
}
</code></pre>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p><strong>伪类的实现就好比给这个标签添加了一个虚拟的类。</strong><br>举个栗子</p>
<pre><code class="html">a:hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>若不用伪类，实现同样的效果，需要这么做</p>
<pre><code class="html">.hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>这么一对比，”伪类“的概念是不是清晰了很多。</p>
<p><strong>而伪元素则好比添加了一个新的标签。</strong></p>
<pre><code class="html">p:first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;Hello,World&lt;/p&gt;
</code></pre>
<p>若不用伪元素，实现同样的效果，需要添加一个额外的标签</p>
<pre><code class="html">.first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;&lt;span class=&quot;first-letter&quot;&gt;H&lt;/span&gt;ello,World&lt;/p&gt;
</code></pre>
<p>因此总结下区分的方法：<strong>现实相同效果是需要添加一个类还是一个元素标签。</strong></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>CSS3为了区别伪类和伪元素，明确使用单冒号来表示伪类，双冒号来表示伪元素。但为兼容性考虑，目前基本还是使用单冒号来表示。</li>
<li>搜索引擎不会搜索伪元素的信息。因此，不要通过伪元素添加你想让搜索引擎索引的重要内容</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解DOM事件流]]></title>
      <url>http://www.sevenhdu.space/2014/10/16/dom-event-flow/</url>
      <content type="html"><![CDATA[<p>当浏览器发展到第四代时（IE4和Netscape Communicator 4）,浏览器团队遇到一个很有意思的问题：页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面。<br>事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流。</p>
<a id="more"></a>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。看下面的例子</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>点击按钮，那么这个click事件会按照以下顺序传播：<br>1.input<br>2.div<br>3.body<br>4.html<br>5.document</p>
<p>虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获。</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。以前面的例子，则会按下图顺序触发事件。</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-15/54841141-file_1487127495480_10fd7.png" alt="事件流"></p>
<p>在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到div后就停止了。下一个阶段是处于目标阶段，于是事件在input上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。</p>
<p>多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上操作事件。  看如下例子。</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;wrap&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var wrap = document.getElementById(&quot;wrap&quot;);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;冒泡&quot;);
            }, false);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;捕获&quot;);
            }, true)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这个Demo的结果，应该很清楚了吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你必须了解的Session的本质]]></title>
      <url>http://www.sevenhdu.space/2014/09/22/you-must-know-the-nature-of-session/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：Chis<br>原文地址：<a href="http://shiflett.org/articles/the-truth-about-sessions" target="_blank" rel="external">The Truth about Sessions</a></p>
</blockquote>
<p>有一点我们必须承认，大多数web应用程序都离不开Session的使用。这篇文章将会结合php以及http协议来分析如何建立一个安全的会话管理机制。我们先简单的了解一些http的知识，从而理解该协议的无状态特性。然后，学习一些关于cookie的基本操作。最后，我会一步步阐述如何使用一些简单，高效的方法来提高你的php应用程序的安全性以及稳定行。</p>
<a id="more"></a>
<p>我想大多数的php初级程序员一定会认为php默认的Session机制的安全性似乎是有一定保障的，事实恰好相反。 php团队只是提供了一套便捷的Session的解决方案提供给程序员使用，至于安全性的话，应该由程序员来加强，这是应用程序开发团队的责任。因为，这里面的方法很多，可以这么说吧，没有最好，只有更好。攻击的方式在不断变化，防守方也需要不断变招，所以，我个人认为php团队的做法还是比较明智的。</p>
<h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>Http是一种无状态性的协议。这是因为此种协议不要求浏览器在每次请求中标明它自己的身份，并且浏览器以及服务器之间并没有保持一个持久性的连接用于多个页面之间的访问。当一个用户访问一个站点的时候，用户的浏览器发送一个http请求到服务器，服务器返回给浏览器一个http响应。其实很简单的一个概念，客户端一个请求，服务器端一个回复，这就是整个基于http协议的通讯过程。</p>
<p>因为web应用程序是基于http协议进行通讯的，而我们已经讲过了http是无状态的，这就增加了维护web应用程序状态的难度, 对于开发者来说，是一个不小的挑战。Cookies是作为http的一个扩展诞生的，其主要用途是弥补http的无状态特性，提供了一种保持客户端与服务器端之间状态的途径，但是由于出于安全性的考虑，有的用户在浏览器中是禁止掉Cookie的。这种情况下，状态信息只能通过url中的参数来传递到服务器端，不过这种方式的安全性很差。事实上，按照通常的想法，应该有客户端来表明自己的身份，从而和服务器之间维持一种状态，但是出于安全性方面的考虑，我们都应该明白一点 – 来自客户端的信息都是不能完全信任的。</p>
<p>尽管这样，针对维持web应用程序状态的问题，相对来说，还是有比较优雅的解决方案的。不过，应该说是没有完美的解决方案，再好的解决方案也不可能适用所有的情况。这篇文章将介绍一些技术。这些技术可以用来比较稳定地维持应用程序的状态以及抵御一些针对Session的攻击，比如会话劫持。并且你可以学习到cookie是怎样工作的，php 的Session做了那些事情，以及怎样才能劫持Session。</p>
<h2 id="HTTP-概览"><a href="#HTTP-概览" class="headerlink" title="HTTP 概览"></a>HTTP 概览</h2><p>如何才能保持web应用程序的状态以及选择最合适的解决方案呢?在回答这个问题之前，必须得先了解web的底层协议 – Hypertext Transfer Protocol (HTTP)。</p>
<p>当用户访问<code>http://example.com</code>这个域名的时候，浏览器就会自动和服务器建立TCP/IP连接，然后发送http请求到example.com的服务器的80端口。该个请求的语法如下所示：</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
</code></pre>
<p>以上第一行叫做请求行，第二个参数(一个反斜线在这个例子中)表示所请求资源的路径。反斜线代表了根目录;服务器会转换这个根目录为服务器文件系统中的一个具体目录。</p>
<p>Apache的用户常用DocumentRoot这个命令来设置这个文档根路径。如果请求的url是 <code>http://example.org/path/to/script.php</code>那么请求的路径就是<code>/path/to/script.php</code>。假如DocumentRoot被定义为<code>usr/lcoal/apache/htdocs</code>的话,整个请求的资源路径就是<code>/usr/local/apache/htdocs/path/to/script.php</code>。</p>
<p>第二行描述的是http头部的语法。在这个例子中的头部是Host, 它标识了浏览器希望获取资源的域名主机。还有很多其它的请求头部可以包含在http请求中，比如user-Agent头部，在php可以通过<code>$_SERVER[&#39;HTTP_USER_AGENT&#39;]</code>获取请求中所携带的这个头部信息。</p>
<p>但是遗憾的是，在这个请求例子中，没有任何信息可以唯一标识当前这个发出请求的客户端。有些开发者借助请求中的ip头部来唯一标识发出此次请求的客户端，但是这种方式存在很多问题。因为，有些用户是通过代理来访问的，比如用户A通过代理B连接网站www.example.com, 服务器端获取的IP信息是代理B分配给A的IP地址，如果用户这时断开代理，然后再次连接代理的话，它的代理IP地址又再次改变，也就说一个用户对应了多个IP地址，这种情况下，服务器端根据IP地址来标识用户的话，会认为请求是来自不同的用户，事实上是同一个用户。 还用另外一种情况就是，比如很多用户是在同一个局域网里通过路由连接互联网，然后都访问www.example.com的话，由于这些用户共享同一个外网IP地址，这会导致服务器认为这些用户是同一个用户发出的请求，因为他们是来自同一个IP地址的访问。</p>
<p>保持应用程序状态的第一步就是要知道如何来唯一地标识每个客户端。因为只有在http中请求中携带的信息才能用来标识客户端，所以在请求中必须包含某种可以用来标识客户端唯一身份的信息。Cookie设计出来就是用来解决这一问题的。</p>
<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>如果你把Cookies看成为http协议的一个扩展的话，理解起来就容易的多了，其实本质上cookies就是http的一个扩展。有两个http头部是专门负责设置以及发送cookie的,它们分别是Set-Cookie以及Cookie。当服务器返回给客户端一个http响应信息时，其中如果包含Set-Cookie这个头部时，意思就是指示客户端建立一个cookie，并且在后续的http请求中自动发送这个cookie到服务器端，直到这个cookie过期。如果cookie的生存时间是整个会话期间的话，那么浏览器会将cookie保存在内存中，浏览器关闭时就会自动清除这个cookie。另外一种情况就是保存在客户端的硬盘中，浏览器关闭的话，该cookie也不会被清除，下次打开浏览器访问对应网站时，这个cookie就会自动再次发送到服务器端。一个cookie的设置以及发送过程分为以下四步：</p>
<ol>
<li>客户端发送一个http请求到服务器端</li>
<li>服务器端发送一个http响应到客户端，其中包含Set-Cookie头部</li>
<li>客户端发送一个http请求到服务器端，其中包含Cookie头部</li>
<li>服务器端发送一个http响应到客户端</li>
</ol>
<p>这个通讯过程也可以用以下下示意图来描述：</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-22/22705650-file_1490113524728_11e4e.png" alt="通讯过程"></p>
<p>在客户端的第二次请求中包含的Cookie头部中，提供给了服务器端可以用来唯一标识客户端身份的信息。这时，服务器端也就可以判断客户端是否启用了cookies。尽管，用户可能在和应用程序交互的过程中突然禁用cookies的使用，但是，这个情况基本是不太可能发生的，所以可以不加以考虑，这在实践中也被证明是对的。</p>
<h2 id="Get、POST数据"><a href="#Get、POST数据" class="headerlink" title="Get、POST数据"></a>Get、POST数据</h2><p>除了cookies,客户端还可以将发送给服务器的数据包含在请求的url中，比如请求的参数或者请求的路径中。 我们来看一个例子：</p>
<pre><code class="HTTP">GET /index.php?foo=bar HTTP/1.1
Host: example.org
</code></pre>
<p>以上就是一个常规的http get 请求，该get请求发送到example.org域名对应的web 服务器下的index.php脚本, 在index.php脚本中，可以通过<code>$_GET[&#39;foo&#39;]</code>来获取对应的url中foo参数的值，也就是bar。大多数php开发者都称这样的数据会GET数据，也有少数称它为查询数据或者url变量。但是大家需要注意一点，不是说GET数据就只能包含在HTTP GET类型的请求中，在HTTP POST类型的请求中同样可以包含GET数据，只要将相关GET数据包含在请求的url中即可，也就是说GET数据的传递不依赖与具体请求的类型。</p>
<p>另外一种客户端传递数据到服务器端的方式是将数据包含在http请求的内容区域内。 这种方式需要请求的类型是POST的，看下面一个例子：</p>
<pre><code class="HTTP">POST /index.php HTTP/1.1
Host: example.org
Content-Type: application/x-www-form-urlencoded
Content-Length: 7
foo=bar
</code></pre>
<p>在这种情况下，在脚本index.php可以通过调用<code>$_POST[&#39;foo&#39;]</code>来获取对应的值bar。开发者称这个数据为POST数据,也就是大家熟知的form以post方式提交请求的方式。</p>
<p>在一个请求中，可以同时包含这两种形式的数据：</p>
<pre><code class="HTTP">POST /index.php?myget=foo HTTP/1.1
Host: example.orgContent-Type: application/x-www-form-urlencoded
Content-Length: 11
mypost=bar
</code></pre>
<p>这两种传递数据的方式，比起用cookies来传递数据更稳定，因为cookie可能被禁用，但是以GET以及POST方式传递数据时，不存在这种情况。我们可以将PHPSESSID包含在http请求的url中，就像下面的例子一样：</p>
<pre><code class="HTTP">GET /index.php?PHPSESSID=12345 HTTP/1.1
Host: example.org
</code></pre>
<p>以这种方式传递session id的话，可以跟用cookie头部传递session id一样，达到同样的效果， 但是，缺点就是需要开发者人为地将session id附加在url中或者作为隐藏字段加入到表单中。不像cookie一样，只要服务器端指示客户端创建cookie成功以后，客户端在后续的请求中，会自动第将对应的没有过期的cookie传递给服务器端。当然，php在开启session.use_trans_sid后，也可以自动地将session id 附加在url中以及表单的隐藏字段中，但是这个选项不建议开启，因为存在安全问题。这样的话，容易泄露session id, 比如有的用户会bookmark一个url或者分享一个url，那么session id也就暴露了，加入这个session id还没有过期，那是有一定的安全问题存在的，除非服务器端，除了session id外，还附加了其它方式进行验证用户的合法性!</p>
<p>尽管以POST的方式来传递session id的话，相对GET的方式来说，会安全的多。但是，这种方式的缺点就是比较麻烦，因为这样的话，在你的应用程序中比较将所有的请求都转换成post的请求，这显然是不太合适的。</p>
<h2 id="Session的管理"><a href="#Session的管理" class="headerlink" title="Session的管理"></a>Session的管理</h2><p>直到现在，我只讨论了如何维护应用程序的状态，只是简单地涉及到了如果保持请求之间的关系。接下来，我阐述下在实际中用到比较多的技术 – Session的管理。涉及到session的管理，就不是单单地维持各个请求之间的状态，还需要维持会话期间针对每个特定用户使用到的数据。我们常常把这种数据叫做session数据，因为这些数据是跟某个特定用户与服务器之间的会话相关联的。如果你使用php内置的session的管理机制，那么session数据一般是保存在/tmp这个服务器端的文件夹中，并且其中的session数据会被自动地保存到超级数组<code>$_SESSION</code>中。一个最简单的使用session的例子，就是将相关的session数据从一个页面传递(注意：实际传递的是session id)到另一个页面。下面用示例代码1, start.php, 对这个例子加以演示：</p>
<pre><code class="php">&lt;?php
    session_start();
    $_SESSION[&quot;foo&quot;] = &quot;bar&quot;;
?&gt;
&lt;a href=&quot;continue.php&quot;&gt;continue.php&lt;/a&gt;
</code></pre>
<p>假如用户点击start.php中的链接访问continue.php,那么在continue.php中就可以通过<code>$_SESSION[&#39;foo&#39;]</code>获取在start.php中的定义的值’bar’。看下面的示例代码2:</p>
<p>示例代码2 – continue.php</p>
<pre><code class="php">&lt;?php
    session_start();
    echo $_SESSION[&quot;foo&quot;];
?&gt;
</code></pre>
<p>是不是非常简单，但是我要指出的话，如果你真的这样来写代码的话，说明你对php底层的对于session的实现机制还不是非常了解透彻。在不了解php内部给你自动做了多少事情的情况下，你会发现如果程序出错的话，这样的代码将变的很难调试，事实上，这样的代码也完全没有安全性可言。</p>
<h2 id="Session的安全问题"><a href="#Session的安全问题" class="headerlink" title="Session的安全问题"></a>Session的安全问题</h2><p>一直以来很多开发者都认为php内置的session管理机制是具有一定的安全性，可以对一般的session攻击起到防御。事实上，这是一种误解，php团队只实现了一种方便有效的机制。具体的安全措施，应该有应用程序的开发团队来实施。 就像开篇谈到的，没有最好的解决方案，只有最合适你的方案。</p>
<p>现在，我们来看下一个比较常规的针对session的攻击：<br>用户访问<code>http://www.example.org</code>，并且登录。<br>example.org的服务器设置指示客户端设置相关cookie – PHPSESSID=12345<br>攻击者这时访问<code>http://www.example.org/</code>,并且在请求中携带了对应的cookie,PHPSESSID=12345<br>这样情况下，因为example.org的服务器通过PHPSESSID来辨认对应的用户的，所以服务器错把攻击者当成了合法的用户。<br>整个过程的描述，请看下面的示例图：</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-3-22/74705136-file_1490114069937_d197.png" alt="Session攻击"></p>
<p>当然这种攻击的方式，前提条件是攻击者必须通过某种手段固定，劫持或者猜测出某个合法用户的PHPSESSID。虽然这看起来难度很高，但是也不是不可能的事情。</p>
<h2 id="安全性的加强"><a href="#安全性的加强" class="headerlink" title="安全性的加强"></a>安全性的加强</h2><p>有很多技术可以用来加强Session的安全性，主要思想就是要使验证的过程对于合法用户来说，越简单越好，然后对于攻击者来说，步骤要越复杂越好。当然，这似乎是比较难于平衡的，要根据你应用程序的具体设计来做决策。</p>
<p>最简单的基于HTTP/1.1请求包括请求行以及一些Host的头部：</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
</code></pre>
<p>如果客户端通过PHPSESSID传递相关的session标识符，可以将PHPSESSID放在cookie头部中进行传递:</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
Cookie: PHPSESSID=12345
</code></pre>
<p>同样地，客户端也可以将session标识符放在请求的url中进行传递。</p>
<pre><code class="HTTP">GET /?PHPSESSID=12345 HTTP/1.1
Host: example.org
</code></pre>
<p>当然，session标识符也可以包含在POST数据中，但是这对用户体验有影响，所以这种方式很少采用。</p>
<p>因为来自TCP/IP信息也不一定可以完全信任的，所以，对于web开发者来说，利用TCP/IP中的信息来加强安全性也是不太合适的。 不过，攻击者也必须提供一个合法用户的唯一的标识符，才能假扮成合法用户进入系统。因此，看起来唯一能够有效的保护系统的措施，就是尽量地隐藏session标识符或者使之难于猜测出来。最好就是两者都能实施。</p>
<p>PHP会自动生成一个随机的session ID，基本来说是不可能被猜测出来的，所以这方面的安全还是有一定保障的。但是，要防止攻击者获取一个合法的session ID是相当困难的，这基本上不是开发者所能控制的。</p>
<p>事实上，许多情况下都有可能导致session ID的泄露。 比如说，如果通过GET数据来传递session ID的话，就有可能暴露这个敏感的身份信息。因为，有的用户可能会将带有session ID的链接缓存，收藏或者发送在邮件内容中。Cookies是一种相对来说安全一点的机制，但是用户是可以在客户端中禁止掉cookies的。在一些IE的版本中也有比较严重的安全漏洞，比较有名的就是会泄露cookies给一些有安全隐患的邪恶站点。</p>
<p>因此，作为一个开发者，可以肯定session ID是不能被猜测出来的，但是还是有可能被攻击者使用某些方法获取到。所以，必须采取一些额外的安全措施来防止此类情况在你的应用程序中发生。</p>
<p>实际上，一个标准的HTTP请求中除了Host等必须包含的头部，还包含了一些可选的头部.举一个例子，看下面的一个请求：</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
Cookie: PHPSESSID=12345
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X; en-US; rv:1.8.1.1) Gecko/20061204 Firefox/2.0.0.1
Accept: text/html;q=0.9, */*;q=0.1
Accept-Charset: ISO-8859-1, utf-8;q=0.66, *;q=0.66
Accept-Language: en
</code></pre>
<p>我们可以看到，在以上的一个请求例子中包含了四个额外的头部，分别是User-Agent, Accept, Accept-Charset以及Accept-Language。因为这些头部不是必须的，所以完全依赖他们在你的应用程序中发挥作用是不太明智的。但是，如果一个用户的浏览器确实发送了这些头部到服务器，那么可以肯定的是在接下来的同一个用户通过同一个浏览器发送的请求中，必然也会携带这些头部。当然，这其中也会有极少数的特殊情况发生。假如以上例子是由一个当前的跟服务器建立了会话的用户发出的请求，考虑下面的一个请求：</p>
<pre><code class="HTTP">GET / HTTP/1.1
Host: example.org
Cookie: PHPSESSID=12345
User-Agent: Mozilla/5.0
</code></pre>
<p>因为有相同的session id包含在请求的Cookie头部中，所以相同的PHPSESSION将会被访问到。但是，请求里的User-Agent头部跟先前的请求中的信息是不同的，系统是否可以假定这两个请求是同一个用户发出的?</p>
<p>像这种情况下，发现浏览器的头部改变了，但是不能肯定这是否是一次来自攻击者的请求的话，比较好的措施就是弹出一个要求输入密码的输入框让用户输入，这样的话，对用户体验的影响不会很大，又能很有效地防止攻击。</p>
<p>当然，你可以在系统中加入核查User-Agent头部的代码，类似示例3中的代码：</p>
<p>示例代码3</p>
<pre><code class="php">&lt;?php  
    session_start();  
    if (md5($_SERVER[&#39;HTTP_USER_AGENT&#39;]) != $_SESSION[&#39;HTTP_USER_AGENT&#39;])  
    {
        /* 弹出密码输入框 */
        exit;
    }  
?&gt;
</code></pre>
<p>当然，你先必须在第一次请求时，初始化session的时候，用MD5算法加密user agent信息并且保存在session中，类似下面示例4中的代码：</p>
<p>示例代码4</p>
<pre><code class="php">&lt;?php  
    session_start();  
    $_SESSION[&#39;HTTP_USER_AGENT&#39;] = md5($_SERVER[&#39;HTTP_USER_AGENT&#39;]);  
?&gt;
</code></pre>
<p>虽然不一定需要用MD5来加密这个User-Agent信息，但使用这种方式以后就不需要再过滤这个<code>$_SERVER[&#39;HTTP_USER_AGENT&#39;]</code>数据了。不然的话，在使用这个数据以前必须要进行数据过滤，因为任何来自客户端的数据都是不可信任的，必须要注意这一点。</p>
<p>在你检查这个User-Agent客户端头部信息以后，做为一个攻击者必须要完成两步才能劫持一个session:</p>
<ol>
<li>获取一个合法的session id</li>
<li>包含一个相同的User-Agent头部在伪造的请求中</li>
</ol>
<p>你可能会说，居然攻击者能获得有效的session id,那么以他的水平，伪造一个相同的User-Agent不是件难事。不错，但是我们可以说这至少给他添加了一些麻烦，在一定程度上也增加了session机制的安全性。</p>
<p>你应该也能想到了，既然我们可以检查User-Agent这个头部来加强安全性，那么不妨再利用其它的一些头部信息，把他们组合起来生成一个加密的token，并且让客户端在后续的请求中携带这个token!这样的话，攻击者基本上不可能猜测出这样一个token是怎么生成出来的。这好比你用信用卡在超市付款，一个你必须有信用卡(好比session id)，另外你也必须输入一个支付密码(好比token),这有这两者都符合的情况下，你才能成功进入账号付款。 看下面一段代码：</p>
<pre><code class="php">&lt;?php  
    session_start();  
    $token = &#39;SHIFLETT&#39; . $_SERVER[&#39;HTTP_USER_AGENT&#39;];
    $_SESSION[&#39;token&#39;] = md5($token . session_id());  
?&gt;
</code></pre>
<p>在你的验证机制中加入了这个非常难于猜测出来的token以后，安全性会得到很大的提升。假如这个token通过像session id一样的方式来进行传递，这种情况下，一个攻击者必须完成必要的3步来劫持用户的session:</p>
<ol>
<li>获取一个合法的session ID</li>
<li>在请求中加入相同的User-Agent头部,用与生成token</li>
<li>在请求中携带被攻击者的token</li>
</ol>
<p>这里面有个问题。如果session id以及token都是通过GET数据来传递的话，那么对于能获取session ID的攻击者，同样就能够获取到这个token。所以，比较安全靠谱的方式应该是利用两种不同的数据传递方式来分别传递session id以及token。例如，通过cookie来传递session id,然后通过GET数据来传递token。因此，假如攻击者通过某种手段获得了这个唯一的用户身份标识，也是不太可能同时轻松地获取到这个token，它相对来说依然是安全的</p>
<p>还有很多的技术手段可以用来加强你的session机制的安全性。希望你在大致了解session的内部本质以后，可以设计出适合你的应用系统的验证机制，从而大大的提高系统的安全性。毕竟，你是最熟悉当下你开发的系统的开发者之一，可以根据实际情况来实施一些特有的，额外的安全措施。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上只是大概地描述了session的工作机制，以及简单地阐述了一些安全措施。但要记住，以上的方法都是能够加强安全性，不是说能够完全保护你的系统，希望读者自己再去调研相关内容。在这个调研过程中，相信你会学到很有实际使用价值的方案。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DB2日期分组计算数据值]]></title>
      <url>http://www.sevenhdu.space/2014/08/18/DB2-sum-groupby/</url>
      <content type="html"><![CDATA[<p>最近参与的项目进行了一次优化技改，对其中SQL参数化公用方法进行了改造。又因项目组人员调整，接手其他模块。</p>
<p>在其他模块测试过程发现，一个针对日期分组计算的SQL报错，报SQL语句超长的异常。</p>
<a id="more"></a>
<p>举个栗子，功能要求如下：</p>
<p>表TABLE_TEST中</p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:center">AMOUNT</th>
<th style="text-align:right">CREATE_DATE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-01</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-09</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-11</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-21</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-24</td>
</tr>
</tbody>
</table>
<p>需求是从表中按CREAT_DATE每10天作为一个分组，统计总金额</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>之前的SQL是这样子的</p>
<pre><code class="SQL">SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-01&#39; AND &#39;2014-01-10&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-11&#39; AND &#39;2014-01-20&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-21&#39; AND &#39;2014-01-30&#39;
</code></pre>
<p>这个SQL主要有两方面问题，一方面程序逻辑发杂，需要算计每10天时间间隔的起始日期，还有一个方面是SQL语句冗长，如果日期跨度大的话，SQL语句就回相当长，直接导致程序抛异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>改进的SQL</p>
<pre><code class="SQL">SELECT SUM(AMOUNT) AS TOTALAMOUNT , (days(CREATE_DATE)-days(&#39;2014-01-01&#39;))/10 AS TIMESAPN
FROM TABLE_TEST GROUP BY TIMESAPN
</code></pre>
<p>关键部分在于  <strong>(days(CREATE_DATE)-days(‘2014-01-01’))/10 AS TIMESAPN</strong></p>
<p>TIMESAPN为0则表示该记录在第一个10天周期内，为1表示在第二个10天周期内，以此类推，最后以此字段作为分组条件，就可以达到上面SQL同样的效果。</p>
]]></content>
    </entry>
    
  
  
</search>
