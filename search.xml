<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[如何在移动端触发手机拨打电话]]></title>
      <url>http://www.sevenhdu.space/2017/03/15/make-call-in-mobile/</url>
      <content type="html"><![CDATA[<p>在移动端的项目中，经常会有这样的需求，点击按钮触发手机拨打电话。<br><a id="more"></a><br>这个需求其实很简单，按照下面的写法其实就可以实现。</p>
<pre><code class="html">&lt;a href=&quot;tel:10086&quot;&gt;拨打电话&lt;/a&gt;
</code></pre>
<p>而最近遇到的需求是电话号码动态变化的，因此想着能不能通过js来动态触发这个动作。搜了一下果然是有方法的。</p>
<pre><code class="javascript">function makeCall(telNo){
    window.location.href = &quot;tel:&quot; + telNo;
}
</code></pre>
<p>亲测，在IOS中微信、Safari、UC以及Android中的微信、UC均可触发拨打电话效果。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo]]></title>
      <url>http://www.sevenhdu.space/2016/09/30/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.<br><a id="more"></a></p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决在IOS下无法自动播放音频的问题]]></title>
      <url>http://www.sevenhdu.space/2016/09/21/autoplay-auido-in-ios/</url>
      <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们知道在IOS下H5页面是无法自动播放音频，必须通过用户交互比如点击等才能播放音频。IOS是为了防止偷跑流量才这么做的。但是很多H5项目中播放背景音频是一个很习以为常的需求。那该怎么办呢？答案就在微信的WeixinJSBridgeReady事件。</p>
<a id="more"></a>
<blockquote>
<p>JavaScript play() and load() methods are also inactive until the user initiates playback, unless the play() or load() method is triggered by user action.</p>
</blockquote>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>WeixinJSBridgeReady是微信自带的事件，只要监听这个事件，在执行函数里播放音频，就可以实现在微信中自动播放音频的功能。（毕竟微信渠道的量大，一定要保证微信是可以正常播放音频）</p>
<pre><code class="html">&lt;audio src=&quot;bgAudio.mp3&quot; id=&quot;bgAudio&quot; preload loop=&quot;loop&quot;&gt;&lt;/audio&gt;
</code></pre>
<pre><code class="javascript">function playBgAudio(){
    var bgAudio = document.getElementById(&quot;bgAudio&quot;);
    bgAudio.play();

    document.addEventListener(&quot;WeixinJSBridgeReady&quot;, function(){
        bgAudio.play();
    }, false);
}
</code></pre>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>很多同学发现用了上面的代码也没什么卵用，因为这里面还有个坑。上面的代码必须放在WeixinJSBridgeReady执行以前，如果WeixinJSBridgeReady事件都执行，再监听就没什么用了。<strong><em>所以监听的js代码一定要放在head前面，以确保最先执行</em></strong>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Atom编辑器快捷键大全]]></title>
      <url>http://www.sevenhdu.space/2016/03/24/Atom-shortcut-keys/</url>
      <content type="html"><![CDATA[<blockquote>
<p>作者：futantan<br>原文地址：<a href="https://github.com/futantan/atom" target="_blank" rel="external">https://github.com/futantan/atom</a></p>
</blockquote>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-24/13908820-file_1487866405842_16c03.png" alt=""></p>
<a id="more"></a>
<h2 id="文件切换"><a href="#文件切换" class="headerlink" title="文件切换"></a>文件切换</h2><p><code>ctrl-shift-s</code>  保存所有打开的文件<br><code>cmd-shift-o</code>  打开目录<br><code>cmd-\</code>   显示或隐藏目录树<br><code>ctrl-0</code>   焦点移到目录树<br>目录树下，使用a，m，delete来增加，修改和删除<br><code>cmd-t</code>或<code>cmd-p</code> 查找文件<br><code>cmd-b</code> 在打开的文件之间切换<br><code>cmd-shift-b</code> 只搜索从上次git commit后修改或者新增的文件</p>
<h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>（等价于上下左右）<br><code>ctrl-p</code> 前一行<br><code>ctrl-n</code> 后一行<br><code>ctrl-f</code> 前一个字符<br><code>ctrl-b</code> 后一个字符  </p>
<p><code>alt-B</code>, <code>alt-left</code> 移动到单词开始<br><code>alt-F</code>, <code>alt-right</code> 移动到单词末尾  </p>
<p><code>cmd-right</code>, <code>ctrl-E</code> 移动到一行结束<br><code>cmd-left</code>, <code>ctrl-A</code>  移动到一行开始  </p>
<p><code>cmd-up</code> 移动到文件开始<br><code>cmd-down</code> 移动到文件结束  </p>
<p><code>ctrl-g</code> 移动到指定行 row:column 处</p>
<p><code>cmd-r</code> 在方法之间跳转</p>
<h2 id="目录树操作"><a href="#目录树操作" class="headerlink" title="目录树操作"></a>目录树操作</h2><p><code>cmd-\</code> 或者 <code>cmd-k cmd-b</code> 显示(隐藏)目录树<br><code>ctrl-0</code> 焦点切换到目录树(再按一次或者<code>Esc</code>退出目录树)<br><code>a</code> 添加文件<br><code>d</code> 将当前文件另存为(duplicate)<br><code>i</code> 显示(隐藏)版本控制忽略的文件<br><code>alt-right</code> 和 <code>alt-left</code> 展开(隐藏)所有目录<br><code>ctrl-al-]</code> 和 <code>ctrl-al-[</code> 同上<br><code>ctrl-[</code> 和 <code>ctrl-]</code> 展开(隐藏)当前目录<br><code>ctrl-f</code> 和 <code>ctrl-b</code> 同上<br><code>cmd-k h</code> 或者 <code>cmd-k left</code> 在左半视图中打开文件<br><code>cmd-k j</code> 或者 <code>cmd-k down</code> 在下半视图中打开文件<br><code>cmd-k k</code> 或者 <code>cmd-k up</code> 在上半视图中打开文件<br><code>cmd-k l</code> 或者 <code>cmd-k right</code> 在右半视图中打开文件<br><code>ctrl-shift-C</code> 复制当前文件绝对路径</p>
<h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p><code>cmd-F2</code> 在本行增加书签<br><code>F2</code> 跳到当前文件的下一条书签<br><code>shift-F2</code> 跳到当前文件的上一条书签<br><code>ctrl-F2</code> 列出当前工程所有书签  </p>
<h2 id="选取"><a href="#选取" class="headerlink" title="选取"></a>选取</h2><blockquote>
<p>大部分和导航一致，只不过加上shift  </p>
</blockquote>
<p><code>ctrl-shift-P</code>  选取至上一行<br><code>ctrl-shift-N</code>  选取至下一样<br><code>ctrl-shift-B</code>  选取至前一个字符<br><code>ctrl-shift-F</code>  选取至后一个字符<br><code>alt-shift-B</code>, <code>alt-shift-left</code>  选取至字符开始<br><code>alt-shift-F</code>, <code>alt-shift-right</code>  选取至字符结束<br><code>ctrl-shift-E</code>, <code>cmd-shift-right</code>  选取至本行结束<br><code>ctrl-shift-A</code>, <code>cmd-shift-left</code>  选取至本行开始<br><code>cmd-shift-up</code>  选取至文件开始<br><code>cmd-shift-down</code>  选取至文件结尾<br><code>cmd-A</code>  全选<br><code>cmd-L</code>  选取一行，继续按回选取下一行<br><code>ctrl-shift-W</code>  选取当前单词  </p>
<h2 id="编辑和删除文本"><a href="#编辑和删除文本" class="headerlink" title="编辑和删除文本"></a>编辑和删除文本</h2><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><code>ctrl-T</code> 使光标前后字符交换<br><code>cmd-J</code> 将下一行与当前行合并<br><code>ctrl-cmd-up</code>, <code>ctrl-cmd-down</code> 使当前行向上或者向下移动<br><code>cmd-shift-D</code> 复制当前行到下一行<br><code>cmd-K</code>, <code>cmd-U</code> 使当前字符大写<br><code>cmd-K</code>, <code>cmd-L</code> 使当前字符小写<br><code>cmd-shift-P</code> 搜索命令  </p>
<h3 id="删除和剪切"><a href="#删除和剪切" class="headerlink" title="删除和剪切"></a>删除和剪切</h3><p><code>ctrl-shift-K</code> 删除当前行<br><code>cmd-backspace</code> 删除到当前行开始<br><code>cmd-fn-backspace</code> 删除到当前行结束<br><code>ctrl-K</code> 剪切到当前行结束<br><code>alt-backspace</code> 或 <code>alt-H</code> 删除到当前单词开始<br><code>alt-delete</code> 或 <code>alt-D</code> 删除到当前单词结束  </p>
<h3 id="多光标和多处选取"><a href="#多光标和多处选取" class="headerlink" title="多光标和多处选取"></a>多光标和多处选取</h3><p><code>cmd-click</code> 增加新光标<br><code>cmd-shift-L</code> 将多行选取改为多行光标<br><code>ctrl-shift-up</code>, <code>ctrl-shift-down</code> 增加上（下）一行光标<br><code>cmd-D</code> 选取文档中和当前单词相同的下一处<br><code>ctrl-cmd-G</code> 选取文档中所有和当前光标单词相同的位置  </p>
<h3 id="括号跳转"><a href="#括号跳转" class="headerlink" title="括号跳转"></a>括号跳转</h3><p><code>ctrl-m</code> 相应括号之间，html tag之间等跳转<br><code>ctrl-cmd-m</code> 括号(tag)之间文本选取<br><code>alt-cmd-.</code> 关闭当前XML/HTML tag  </p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p><code>ctrl-shift-U</code> 调出切换编码选项  </p>
<h2 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h2><p><code>cmd-F</code> 在buffer中查找<br><code>cmd-shift-f</code> 在整个工程中查找  </p>
<h2 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h2><p><code>alt-shift-S</code> 查看当前可用代码片段  </p>
<blockquote>
<p>在<code>~/.atom</code>目录下<code>snippets.cson</code>文件中存放了你定制的snippets  </p>
</blockquote>
<p><a href="https://atom.io/docs/v1.0.0/using-atom-snippets" target="_blank" rel="external">定制说明</a>  </p>
<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p><code>ctrl-space</code> 提示补全信息  </p>
<h2 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h2><p><code>alt-cmd-[</code> 折叠<br><code>alt-cmd-]</code> 展开<br><code>alt-cmd-shift-{</code> 折叠全部<br><code>alt-cmd-shift-}</code> 展开全部<br><code>cmd-k cmd-N</code> 指定折叠层级 N为层级数  </p>
<h2 id="文件语法高亮"><a href="#文件语法高亮" class="headerlink" title="文件语法高亮"></a>文件语法高亮</h2><p><code>ctrl-shift-L</code> 选择文本类型  </p>
<h2 id="使用Atom进行写作"><a href="#使用Atom进行写作" class="headerlink" title="使用Atom进行写作"></a>使用Atom进行写作</h2><p><code>ctrl-shift-M</code> Markdown预览<br>可用代码片段</p>
<blockquote>
<p>b, legal, img, l, i, code, t, table</p>
</blockquote>
<h2 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h2><p><code>cmd-alt-Z</code> checkout HEAD 版本<br><code>cmd-shift-B</code> 弹出untracked 和 modified文件列表<br><code>alt-g down</code> <code>alt-g up</code> 在修改处跳转<br><code>alt-G D</code> 弹出diff列表<br><code>alt-G O</code> 在github上打开文件<br><code>alt-G G</code> 在github上打开项目地址<br><code>alt-G B</code> 在github上打开文件blame<br><code>alt-G H</code> 在github上打开文件history<br><code>alt-G I</code> 在github上打开issues<br><code>alt-G R</code> 在github打开分支比较<br><code>alt-G C</code> 拷贝当前文件在gihub上的网址</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS3中的transform]]></title>
      <url>http://www.sevenhdu.space/2015/06/15/CSS3-transform/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>transform可以对元素应用2D或3D变换，包括移动（translate）、缩放（scale）、倾斜（skew）、旋转（rotate）。通过transform可以做出很多动画效果。</p>
<a id="more"></a>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><table>
<thead>
<tr>
<th style="text-align:left">例子</th>
<th style="text-align:right">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">translate(50px, 100px)</td>
<td style="text-align:right">元素向右平移50px,向下平移100px</td>
</tr>
<tr>
<td style="text-align:left">scale(2, 3)</td>
<td style="text-align:right">元素宽度扩大2倍，高度扩大3倍</td>
</tr>
<tr>
<td style="text-align:left">skew(20deg)</td>
<td style="text-align:right">元素在X轴倾斜20°</td>
</tr>
<tr>
<td style="text-align:left">rotate(60deg)</td>
<td style="text-align:right">元素顺时针旋转60°</td>
</tr>
</tbody>
</table>
<p>可以同一个元素使用多个不同类型的变换，只要变换之间以空格隔开</p>
<pre><code class="css">transform: translate(50px, 100px) scale(2, 3) rotate(60deg);
</code></pre>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>直接上例子，为了让变换不那么生硬，加了过渡属性transition。</p>
<iframe height="265" scrolling="no" title="CSS3 transform" src="//codepen.io/SevenHDU/embed/YZxROr/?height=265&theme-id=0&default-tab=css,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="https://codepen.io/SevenHDU/pen/YZxROr/" target="_blank" rel="external">CSS3 transform</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>

<h2 id="transform-origin的玄机"><a href="#transform-origin的玄机" class="headerlink" title="transform-origin的玄机"></a>transform-origin的玄机</h2><p>transfrom属性和transform-origin是息息相关的。transform是以tranform-origin的值作为原点进行变换的，默认是中心点。<br>看下面的例子。</p>
<iframe height="300" scrolling="no" title="Transform-origin" src="//codepen.io/SevenHDU/embed/wJrggy/?height=300&theme-id=0&default-tab=html,result&embed-version=2" frameborder="no" allowtransparency="true" allowfullscreen="true" style="width: 100%;">See the Pen <a href="http://codepen.io/SevenHDU/pen/wJrggy/" target="_blank" rel="external">Transform-origin</a> by Seven (<a href="http://codepen.io/SevenHDU" target="_blank" rel="external">@SevenHDU</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.<br></iframe>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS中的伪类和伪元素]]></title>
      <url>http://www.sevenhdu.space/2015/03/05/css-pseudo-class-and-pseudo-elments/</url>
      <content type="html"><![CDATA[<p>先看<code>W3C</code>的定义<br>. <strong>CSS伪类</strong> 用于向某些选择器添加特殊的效果<br>. <strong>CSS伪元素</strong> 用于向某些选择器设置特殊效果</p>
<p>光看定义，其实还是云里雾里的，所以还是要深入研究下才能搞明白他们的作用。</p>
<a id="more"></a>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>伪类与类相似，但又没有类附加标签上。伪类分为UI伪类和结构化伪类。</p>
<h3 id="UI伪类"><a href="#UI伪类" class="headerlink" title="UI伪类"></a>UI伪类</h3><ul>
<li>:link(将样式添加到未被访问的链接上)</li>
<li>:visted(将样式已添加到访问的链接上)</li>
<li>:hover(将样式添加到鼠标悬浮的元素上)</li>
<li>:active(将样式添加到被激活的元素上)</li>
<li>:focus(将样式添加到被选中的元素上)</li>
</ul>
<h3 id="结构化伪类"><a href="#结构化伪类" class="headerlink" title="结构化伪类"></a>结构化伪类</h3><ul>
<li>:first-child(将样式添加到第一个子元素上)</li>
<li>:last-child(将样式添加到最后一个子元素上)</li>
</ul>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素是在文档中若有实无的元素。<br>主要有以下几种</p>
<ul>
<li>:first-letter(将样式添加到第一个字母)</li>
<li>:first-line(将样式添加到第一行)</li>
<li>:before(在某些元素前面插入某些内容)</li>
<li>:after(在某些元素后面插入某些内容)</li>
</ul>
<p>看到:after，大家脑子里应该都能想到那个经典的清除浮动的CSS的吧。没错，就是这个。</p>
<pre><code class="css">.clearfix:after {
    content:&quot;.&quot;;
    display:block;
    height:0;
    visibility:hidden;
    clear:both;
}
</code></pre>
<h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p><strong>伪类的实现就好比给这个标签添加了一个虚拟的类。</strong><br>举个栗子</p>
<pre><code class="html">a:hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>若不用伪类，实现同样的效果，需要这么做</p>
<pre><code class="html">.hover{
    font-size:20px;
    color:red
}
&lt;a href=&quot;#&quot; class=&quot;hover&quot;&gt;Hello,World&lt;/a&gt;
</code></pre>
<p>这么一对比，”伪类“的概念是不是清晰了很多。</p>
<p><strong>而伪元素则好比添加了一个新的标签。</strong></p>
<pre><code class="html">p:first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;Hello,World&lt;/p&gt;
</code></pre>
<p>若不用伪元素，实现同样的效果，需要添加一个额外的标签</p>
<pre><code class="html">.first-letter{
    font-size:20px;
    color:red
}
&lt;p&gt;&lt;span class=&quot;first-letter&quot;&gt;H&lt;/span&gt;ello,World&lt;/p&gt;
</code></pre>
<p>因此总结下区分的方法：<strong>现实相同效果是需要添加一个类还是一个元素标签。</strong></p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol>
<li>CSS3为了区别伪类和伪元素，明确使用单冒号来表示伪类，双冒号来表示伪元素。但为兼容性考虑，目前基本还是使用单冒号来表示。</li>
<li>搜索引擎不会搜索伪元素的信息。因此，不要通过伪元素添加你想让搜索引擎索引的重要内容</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[深入理解DOM事件流]]></title>
      <url>http://www.sevenhdu.space/2014/10/16/dom-event-flow/</url>
      <content type="html"><![CDATA[<p>当浏览器发展到第四代时（IE4和Netscape Communicator 4）,浏览器团队遇到一个很有意思的问题：页面的哪一部分会拥有特定的事件？想象下在一张纸上有一组同心圆，如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是一组圆。两家公司的开发团队在看待浏览器事件方面还是一致的。如果你单击了某个按钮，那么同时你也单击了按钮的容器元素，甚至整个页面。<br>事件流描述的是从页面中接受事件的顺序。但有意思的是，IE和Netscape开发团队居然提出了两个截然相反的事件流概念。IE的事件流是事件冒泡流，而Netscape的事件流是事件捕获流。</p>
<a id="more"></a>
<h2 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h2><p>IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。看下面的例子</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>点击按钮，那么这个click事件会按照以下顺序传播：<br>1.input<br>2.div<br>3.body<br>4.html<br>5.document</p>
<p>虽然事件捕获是Netscape唯一支持的事件流模型，但IE9、Safari、Chrome、Opera和Firefox目前也都支持这种事件流模型。但由于老版本的浏览器不支持，因此很少有人使用事件捕获。</p>
<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。以前面的例子，则会按下图顺序触发事件。</p>
<p><img src="http://ojf54mxmq.bkt.clouddn.com//17-2-15/54841141-file_1487127495480_10fd7.png" alt="事件流"></p>
<p>在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到div后就停止了。下一个阶段是处于目标阶段，于是事件在input上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。</p>
<p>多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox和Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上操作事件。  看如下例子。</p>
<pre><code class="html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;事件流&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;div id=&quot;wrap&quot;&gt;
            &lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;按钮&quot; /&gt;
        &lt;/div&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            var wrap = document.getElementById(&quot;wrap&quot;);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;冒泡&quot;);
            }, false);
            wrap.addEventListener(&quot;click&quot;, function(){
                alert(&quot;捕获&quot;);
            }, true)
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>这个Demo的结果，应该很清楚了吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[DB2日期分组计算数据值]]></title>
      <url>http://www.sevenhdu.space/2014/08/18/DB2-sum-groupby/</url>
      <content type="html"><![CDATA[<p>最近参与的项目进行了一次优化技改，对其中SQL参数化公用方法进行了改造。又因项目组人员调整，接手其他模块。</p>
<p>在其他模块测试过程发现，一个针对日期分组计算的SQL报错，报SQL语句超长的异常。</p>
<a id="more"></a>
<p>举个栗子，功能要求如下：</p>
<p>表TABLE_TEST中</p>
<table>
<thead>
<tr>
<th style="text-align:left">ID</th>
<th style="text-align:center">AMOUNT</th>
<th style="text-align:right">CREATE_DATE</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-01</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-09</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-11</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-21</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:center">100</td>
<td style="text-align:right">2014-01-24</td>
</tr>
</tbody>
</table>
<p>需求是从表中按CREAT_DATE每10天作为一个分组，统计总金额</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>之前的SQL是这样子的</p>
<pre><code class="SQL">SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-01&#39; AND &#39;2014-01-10&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-11&#39; AND &#39;2014-01-20&#39;
UNION ALL
SELECT SUM(AMOUT) AS TOTALAMOUNT FORM TABLE_TEST
WHERE CREATE_DATE BETWEEN &#39;2014-01-21&#39; AND &#39;2014-01-30&#39;
</code></pre>
<p>这个SQL主要有两方面问题，一方面程序逻辑发杂，需要算计每10天时间间隔的起始日期，还有一个方面是SQL语句冗长，如果日期跨度大的话，SQL语句就回相当长，直接导致程序抛异常。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>改进的SQL</p>
<pre><code class="SQL">SELECT SUM(AMOUNT) AS TOTALAMOUNT , (days(CREATE_DATE)-days(&#39;2014-01-01&#39;))/10 AS TIMESAPN
FROM TABLE_TEST GROUP BY TIMESAPN
</code></pre>
<p>关键部分在于  <strong>(days(CREATE_DATE)-days(‘2014-01-01’))/10 AS TIMESAPN</strong></p>
<p>TIMESAPN为0则表示该记录在第一个10天周期内，为1表示在第二个10天周期内，以此类推，最后以此字段作为分组条件，就可以达到上面SQL同样的效果。</p>
]]></content>
    </entry>
    
  
  
</search>
